{{- if or (not .Values.apache.customDefaultSiteConfigMap) (not .Values.apache.customPortsConfigMap) (not .Values.apache.customPhpConfigMap) (not .Values.wordpress.htaccessConfigMap)  }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "wordpress.fullname" . }}-configfiles
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "wordpress.labels" . | nindent 4 }}
data:
  {{- if (not .Values.apache.customDefaultSiteConfigMap)  }}
  000-default.conf: |
    {{- if .Values.apache.customDefaultSiteConfig }}
    {{ .Values.apache.customDefaultSiteConfig | nindent 4 }}
    {{- else if .Values.metrics.apache.enabled }}
    <VirtualHost *:{{ .Values.service.ports.http }}>
            ServerAdmin webmaster@localhost
            <Location "/server-status">
                    SetHandler server-status
                    Require local
            </Location>
            DocumentRoot /var/www/html
            ErrorLog ${APACHE_LOG_DIR}/error.log
            CustomLog ${APACHE_LOG_DIR}/access.log combined
    </VirtualHost>
    {{- else }}
    <VirtualHost *:{{ .Values.service.ports.http }}>
            ServerAdmin webmaster@localhost
            DocumentRoot /var/www/html

            ErrorLog ${APACHE_LOG_DIR}/error.log
            CustomLog ${APACHE_LOG_DIR}/access.log combined
    </VirtualHost>
    {{- end }}
  {{- end }}
  {{- if (not .Values.apache.customPortsConfigMap) }}
  ports.conf: |
    {{- if .Values.apache.customPortsConfig }}
    {{ .Values.apache.customPortsConfig | nindent 4 }}
    {{- else }}
    Listen {{ .Values.service.ports.http }}
    {{- end }}
  {{- end }}
  {{- if (not .Values.apache.customPhpConfigMap) }}
  custom.ini: |
    {{- if and .Values.apache.customPhpConfig  (not .Values.apache.customPhpConfigMap) }}
    {{ .Values.apache.customPhpConfig | nindent 4 }}
    {{- end }}
  {{- end }}
  {{- if (not .Values.wordpress.htaccessConfigMap) }}
  htaccess: |
    {{- if and .Values.wordpress.htaccess  (not .Values.wordpress.htaccessConfigMap) }}
    {{ .Values.wordpress.htaccess | nindent 4 }}
    {{ else if .Values.metrics.apache.enabled }}
    # Server-status exception
    <IfModule mod_rewrite.c>
    RewriteRule ^server-status - [L]
    </IfModule>

    # BEGIN WordPress
    # The directives (lines) between "BEGIN WordPress" and "END WordPress" are
    # dynamically generated and will be automatically injected by the init container.
    # Any changes to the directives between these markers will be overwritten.
    # END WordPress
    {{ else }}
    # BEGIN WordPress
    # The directives (lines) between "BEGIN WordPress" and "END WordPress" are
    # dynamically generated and will be automatically injected by the init container.
    # Any changes to the directives between these markers will be overwritten.
    # END WordPress
    {{- end }}
  {{- end }}
{{- end }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "wordpress.fullname" . }}-init
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "wordpress.labels" . | nindent 4 }}
data:
  base.sh: |
    #!/bin/bash
    # Check if WordPress files exist; if not copy them but exclude wp-content.
    if [ ! -e /tmp/wordpress/index.php ] && [ ! -e /tmp/wordpress/wp-includes/version.php ]; then
        echo "WordPress not found in /tmp/wordpress - copying now..."
        # Use a for loop to copy everything except wp-content
        mkdir -p /tmp/wordpress
        cd /usr/src/wordpress || exit 0
        for item in *; do
          if [ "$item" != "wp-content" ]; then
            cp -r "$item" /tmp/wordpress/ || exit 1
          fi
          # Handle wp-config-docker.php
          if [ "$item" = "wp-config-docker.php" ] && [ ! -s /tmp/wordpress/wp-config.php ]; then
            awk '
              /put your unique phrase here/ {
                cmd = "head -c1m /dev/urandom | sha1sum | cut -d\\  -f1"
                cmd | getline str
                close(cmd)
                gsub("put your unique phrase here", str)
              }
              { print }
            ' "$item" > /tmp/wordpress/wp-config.php
          fi
        done
        
        # Also try to copy any existing wp-content from /var/www/html if present
        if [ ! -d /tmp/wordpress/wp-content ]; then
            cp -r /var/www/html/wp-content /tmp/wordpress/wp-content 2>/dev/null || true
        fi
        echo "Complete! WordPress has been successfully copied to /tmp/wordpress"
    else
        echo "WordPress already present in /tmp/wordpress - skipping copy"
    fi
    
    # ============================================================================
    # Setup MU-Plugins from ConfigMaps
    # ============================================================================
    {{- if .Values.wordpress.muPluginsConfigMaps }}
    echo ""
    echo "Setting up MU-Plugins from ConfigMaps..."
    echo "========================================="
    
    # Create mu-plugins directory if it doesn't exist
    mkdir -p /tmp/wordpress/wp-content/mu-plugins
    chown www-data:www-data /tmp/wordpress/wp-content/mu-plugins
    chmod 755 /tmp/wordpress/wp-content/mu-plugins
    
    {{- range .Values.wordpress.muPluginsConfigMaps }}
    # Copy files from ConfigMap: {{ .name }}
    if [ -d "/tmp/mu-plugins-{{ .name }}" ]; then
      {{- if .key }}
      # Copy specific key only
      if [ -f "/tmp/mu-plugins-{{ .name }}/{{ .key }}" ]; then
        echo "Copying MU-Plugin file {{ .key }} from {{ .name }}..."
        cp /tmp/mu-plugins-{{ .name }}/{{ .key }} /tmp/wordpress/wp-content/mu-plugins/
        chown www-data:www-data /tmp/wordpress/wp-content/mu-plugins/{{ .key }}
        chmod 644 /tmp/wordpress/wp-content/mu-plugins/{{ .key }}
        echo "MU-Plugin file {{ .key }} from {{ .name }} copied successfully!"
      else
        echo "Warning: Key {{ .key }} not found in ConfigMap {{ .name }}"
      fi
      {{- else }}
      # Copy all files from ConfigMap
      echo "Copying all MU-Plugin files from {{ .name }}..."
      cp -r -L /tmp/mu-plugins-{{ .name }}/* /tmp/wordpress/wp-content/mu-plugins/ 2>/dev/null || true
      # Set correct ownership and permissions for all copied files
      find /tmp/wordpress/wp-content/mu-plugins -type f -exec chown www-data:www-data {} \;
      find /tmp/wordpress/wp-content/mu-plugins -type f -exec chmod 644 {} \;
      echo "MU-Plugin files from {{ .name }} copied successfully!"
      {{- end }}
    else
      echo "Warning: MU-Plugin ConfigMap mount {{ .name }} not found"
    fi
    {{- end }}
    
    echo "MU-Plugins setup completed!"
    {{- else }}
    echo "No MU-Plugins ConfigMaps configured."
    {{- end }}
    
    # ============================================================================
    # Custom Init Commands ConfigMap Info
    # ============================================================================
    {{- if .Values.wordpress.init.customInitConfigMap.name }}
    echo ""
    echo "Custom init commands ConfigMap detected: {{ .Values.wordpress.init.customInitConfigMap.name }}"
    {{- end }}
    
    echo "========================================="
    echo "Base script completed!"
    echo "========================================="
  htaccess-setup.sh: |
    #!/bin/sh
    # Script to setup .htaccess on persistent volume
    # This runs in the base init container
    
    echo "Starting .htaccess setup..."
    
    # Copy and make injection script executable once
    cp /tmp/scripts/htaccess-inject.sh /tmp/htaccess-inject.sh
    chmod +x /tmp/htaccess-inject.sh
    
    # Check if .htaccess already exists on persistent volume
    if [ ! -f /tmp/wordpress/.htaccess ]; then
      echo ".htaccess not found on persistent volume, creating from ConfigMap..."
      
      # Copy .htaccess from ConfigMap and inject WordPress rules
      /tmp/htaccess-inject.sh \
        /tmp/configfiles/.htaccess \
        /tmp/wordpress/.htaccess \
        /tmp/scripts/wordpress-rewrite-rules.txt
      
      # Set correct ownership and permissions
      chown www-data:www-data /tmp/wordpress/.htaccess
      chmod 664 /tmp/wordpress/.htaccess
      echo "WordPress rewrite rules successfully injected and written to persistent volume!"
    else
      echo ".htaccess already exists on persistent volume."
      
      # Extract WordPress block content from existing file (if it exists)
      if grep -q "# BEGIN WordPress" /tmp/wordpress/.htaccess; then
        echo "Extracting WordPress block content from existing .htaccess..."
        
        # Extract ONLY the content between markers (excluding the markers themselves)
        awk '/# BEGIN WordPress/,/# END WordPress/{if (!/# BEGIN WordPress/ && !/# END WordPress/) print}' /tmp/wordpress/.htaccess > /tmp/wp-block-content.txt
        
        # Start with fresh ConfigMap .htaccess and inject the existing WordPress block content
        /tmp/htaccess-inject.sh \
          /tmp/configfiles/.htaccess \
          /tmp/htaccess-new \
          /tmp/wp-block-content.txt
        
        # Replace old .htaccess with updated one
        mv /tmp/htaccess-new /tmp/wordpress/.htaccess
        chown www-data:www-data /tmp/wordpress/.htaccess
        chmod 664 /tmp/wordpress/.htaccess
        echo "ConfigMap .htaccess updated with existing WordPress block content!"
      else
        echo "No WordPress block found in existing .htaccess."
        
        # Inject default WordPress rules into fresh ConfigMap .htaccess
        /tmp/htaccess-inject.sh \
          /tmp/configfiles/.htaccess \
          /tmp/htaccess-new \
          /tmp/scripts/wordpress-rewrite-rules.txt
        
        # Replace old .htaccess with updated one
        mv /tmp/htaccess-new /tmp/wordpress/.htaccess
        chown www-data:www-data /tmp/wordpress/.htaccess
        chmod 664 /tmp/wordpress/.htaccess
        echo "ConfigMap .htaccess applied with default WordPress rules!"
      fi
    fi
    
    echo "========================================="
    echo ".htaccess setup completed!"
    echo "========================================="
  wordpress-rewrite-rules.txt: |
    <IfModule mod_rewrite.c>
    RewriteEngine On
    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
    RewriteBase /
    RewriteRule ^index\.php$ - [L]
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteRule . /index.php [L]
    </IfModule>
  htaccess-inject.sh: |
    #!/bin/sh
    # Script to inject WordPress rewrite rules into .htaccess
    # Usage: htaccess-inject.sh <source-htaccess> <output-htaccess> <rules-file>
    
    SOURCE_FILE="$1"
    OUTPUT_FILE="$2"
    RULES_FILE="$3"
    
    awk -v rules_file="$RULES_FILE" '
    BEGIN { 
        in_wp=0
        wp_done=0
        # Read rules from file
        while ((getline line < rules_file) > 0) {
            rules = rules line "\n"
        }
        close(rules_file)
    }
    /# BEGIN WordPress/ { 
        print
        printf "%s", rules
        in_wp=1
        wp_done=1
        next
    }
    /# END WordPress/ { in_wp=0 }
    !in_wp || !wp_done { print }
    ' "$SOURCE_FILE" > "$OUTPUT_FILE"
  init.sh: |
    #!/bin/bash
    set -e
    
    echo "Starting init script..."
    
    # ============================================================================
    # Configuration Constants
    # ============================================================================
    
    # Database lock configuration
    readonly CHECK_INTERVAL=5
    readonly STALE_LOCK_THRESHOLD=120  # Consider lock stale after 2 minutes (handles pod deletion)
    readonly MAX_WAIT=$((STALE_LOCK_THRESHOLD + 30))  # Wait a bit longer than stale threshold
    readonly DB_CHECK_RETRY_INTERVAL=15  # Seconds between database connection checks
    
    # WordPress paths
    readonly WP_PLUGINS_DIR="wp-content/plugins"
    readonly WP_THEMES_DIR="wp-content/themes"
    readonly WP_MU_PLUGINS_DIR="wp-content/mu-plugins"
    
    # Composer configuration
    readonly COMPOSER_HOME_DIR="/tmp/.composer"
    readonly COMPOSER_INSTALL_DIR="/tmp"
    
    # Runtime variables
    WAIT_TIME=0
    COMPOSER_PACKAGES_MODIFIED=false
    
    # ============================================================================
    # Database Lock Functions
    # Uses WordPress options table as distributed lock across all pods
    # ============================================================================
    
    # Attempt to claim distributed database lock for initialization
    # Ensures only one pod performs WordPress configuration at a time
    # 
    # Returns:
    #   0 - Lock successfully claimed or taken over from stale lock
    #   1 - Lock held by another active pod
    # 
    # Implementation:
    #   - Uses wp_options table with option_name='_helm_init_lock'
    #   - Lock value format: "POD_ID-TIMESTAMP"
    #   - Detects stale locks (older than STALE_LOCK_THRESHOLD seconds)
    claim_lock_db() {
      CURRENT_TIME=$(date +%s)
      POD_ID="$$-$(hostname)"
      
      # Get table prefix dynamically
      TABLE_PREFIX=$(wp db prefix 2>/dev/null || echo "wp_")
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Using table prefix: $TABLE_PREFIX" >&2
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Attempting to claim lock with POD_ID=$POD_ID-$CURRENT_TIME" >&2
      
      # Check if wp_options table exists - if not, it's a fresh install
      if ! wp db query "SHOW TABLES LIKE '${TABLE_PREFIX}options';" --skip-column-names 2>/dev/null | grep -q "${TABLE_PREFIX}options"; then
        [ "${DEBUG}" = "true" ] && echo "DEBUG: wp_options table doesn't exist yet, claiming lock for fresh install" >&2
        return 0
      fi
      
      # Try to insert lock row - ignore error if already exists
      wp db query "INSERT IGNORE INTO ${TABLE_PREFIX}options (option_name, option_value, autoload) VALUES ('_helm_init_lock', '$POD_ID-$CURRENT_TIME', 'no');" >/dev/null 2>&1
      INSERT_RESULT=$?
      [ "${DEBUG}" = "true" ] && echo "DEBUG: INSERT result: $INSERT_RESULT" >&2
      
      # Check if we actually got the lock
      LOCK_OWNER=$(wp db query "SELECT option_value FROM ${TABLE_PREFIX}options WHERE option_name='_helm_init_lock';" --skip-column-names 2>/dev/null || echo "")
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Current lock owner: $LOCK_OWNER" >&2
      
      if [[ "$LOCK_OWNER" == "$POD_ID-$CURRENT_TIME" ]]; then
        [ "${DEBUG}" = "true" ] && echo "DEBUG: Successfully claimed lock!" >&2
        return 0
      fi
      
      # Check for stale lock (older than threshold)
      LOCK_TIME=$(echo "$LOCK_OWNER" | awk -F'-' '{print $NF}')
      if [[ "$LOCK_TIME" =~ ^[0-9]+$ ]]; then
        LOCK_AGE=$((CURRENT_TIME - LOCK_TIME))
        [ "${DEBUG}" = "true" ] && echo "DEBUG: Lock age: ${LOCK_AGE}s (threshold: ${STALE_LOCK_THRESHOLD}s)" >&2
        if [ $LOCK_AGE -gt $STALE_LOCK_THRESHOLD ]; then
          echo "Found stale lock (${LOCK_AGE}s old), taking over..." >&2
          wp db query "UPDATE ${TABLE_PREFIX}options SET option_value='$POD_ID-$CURRENT_TIME' WHERE option_name='_helm_init_lock';" >/dev/null 2>&1
          return 0
        fi
      else
        [ "${DEBUG}" = "true" ] && echo "DEBUG: Lock time is not numeric: $LOCK_TIME" >&2
      fi
      
      return 1
    }
    
    # Release database lock by deleting the lock row
    # Called automatically via trap on script exit
    # Safe to call even if lock doesn't exist (|| true)
    release_lock() {
      TABLE_PREFIX=$(wp db prefix 2>/dev/null || echo "wp_")
      wp db query "DELETE FROM ${TABLE_PREFIX}options WHERE option_name='_helm_init_lock';" >/dev/null 2>&1 || true
      echo "Database lock released"
    }
    
    trap release_lock EXIT
    
    # ============================================================================
    # Helper Functions
    # ============================================================================
    
    # WP-CLI wrapper with optional debug output
    # Uses global DEBUG flag to control verbosity
    # 
    # Args: All arguments are passed through to wp-cli
    wp() {
      if [ "${DEBUG}" = "true" ]; then
        command wp --path="${WORDPRESS_PATH}" --debug "$@"
      else
        command wp --path="${WORDPRESS_PATH}" "$@"
      fi
    }

    # Run commands with optional output suppression based on DEBUG flag
    # 
    # Args: Command and arguments to execute
    run() {
      if [ "${DEBUG}" = "true" ]; then
        "$@"
      else
        "$@" >/dev/null 2>&1
      fi
    }
    
    # Standardized error handler
    # Logs error message and exits with code 1
    # 
    # Args:
    #   $1 - Error message to display
    handle_error() {
      echo "ERROR: $1" >&2
      exit 1
    }
    
    # Install Composer on-demand to temporary directory
    # Downloads, verifies checksum, and installs to COMPOSER_INSTALL_DIR
    # Idempotent - skips if composer already available
    ensure_composer() {
      # Set Composer home to writable directory
      export COMPOSER_HOME="${COMPOSER_HOME_DIR}"
      mkdir -p "$COMPOSER_HOME"
      
      if ! command -v composer &> /dev/null; then
        echo "Composer not found, installing..."
        cd "${COMPOSER_INSTALL_DIR}" || handle_error "Cannot access Composer install directory"
        
        # Download and verify Composer installer
        php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"
        EXPECTED_CHECKSUM="$(php -r 'copy("https://composer.github.io/installer.sig", "php://stdout");')"
        ACTUAL_CHECKSUM="$(php -r "echo hash_file('sha384', 'composer-setup.php');")"
        
        if [ "$EXPECTED_CHECKSUM" != "$ACTUAL_CHECKSUM" ]; then
          rm composer-setup.php
          handle_error "Invalid Composer installer checksum"
        fi
        
        # Install Composer to temporary location - suppress output
        php composer-setup.php --quiet --install-dir="${COMPOSER_INSTALL_DIR}" --filename=composer 2>&1 | grep -v "PHP version" | grep -v "diagnose" || true
        rm composer-setup.php
        
        # Add to PATH for this session
        export PATH="${COMPOSER_INSTALL_DIR}:$PATH"
        
        echo "Composer installed successfully: $(composer --version 2>&1 | head -n1)"
      fi
    }
    
    # ============================================================================
    # Wait for Database
    # ============================================================================
    
    echo "Waiting for database..."
    until run wp db check; do
      echo "Database not ready yet, waiting ${DB_CHECK_RETRY_INTERVAL} seconds..."
      sleep "${DB_CHECK_RETRY_INTERVAL}"
    done
    
    # ============================================================================
    # WordPress Installation (First-Time Only)
    # ============================================================================
    
    if [ "${WP_INIT}" = "true" ]; then
      if ! run wp core is-installed --url="${WP_URL}"; then
        echo "========================================="
        echo "Setting up WordPress..."
        echo "========================================="
        run wp core install \
          --url="${WP_URL}" \
          --title="${WP_TITLE}" \
          --admin_user="${WP_ADMIN_USER}" \
          --admin_password="${WP_ADMIN_PASSWORD}" \
          --admin_email="${WP_ADMIN_EMAIL}" \
          --skip-email \
          --locale="${WP_LOCALE}"
      else
        echo "WordPress is already installed, skipping installation."
      fi
    else
      # WP_INIT is false - check if WordPress is already installed
      TABLE_PREFIX=$(wp db prefix 2>/dev/null || echo "wp_")
      
      # Check if wp_options table exists
      if ! wp db query "SHOW TABLES LIKE '${TABLE_PREFIX}options';" --skip-column-names 2>/dev/null | grep -q "${TABLE_PREFIX}options"; then
        echo "========================================="
        echo "ERROR: WordPress database tables not found!"
        echo "========================================="
        echo ""
        echo "The database exists but WordPress tables are missing."
        echo "This indicates one of the following issues:"
        echo ""
        echo "1. WordPress initialization has not been performed yet"
        echo "   -> Set wordpress.init.enabled=true in your values.yaml"
        echo ""
        echo "2. Wrong table prefix configured"
        echo "   -> Current prefix: ${TABLE_PREFIX}"
        echo "   -> Check wordpress.tablePrefix in your values.yaml"
        echo ""
        echo "3. Database was reset but persistent volume still exists"
        echo "   -> Delete the PVC and reinstall"
        echo ""
        echo "========================================="
        exit 1
      fi
      
      echo "WordPress tables found, continuing with configuration..."
    fi
    
    # ============================================================================
    # Acquire Database Lock
    # Ensures only one pod performs initialization at a time
    # ============================================================================
    
    echo "Acquiring database lock for initialization..."
    while ! claim_lock_db; do
      if [ $WAIT_TIME -ge $MAX_WAIT ]; then
        echo "Timeout waiting for database lock after ${MAX_WAIT}s"
        
        # Final attempt to forcefully claim the lock
        POD_ID="$$-$(hostname)"
        CURRENT_TIME=$(date +%s)
        TABLE_PREFIX=$(wp db prefix 2>/dev/null || echo "wp_")
        wp db query "UPDATE ${TABLE_PREFIX}options SET option_value='$POD_ID-$CURRENT_TIME' WHERE option_name='_helm_init_lock';" >/dev/null 2>&1 || \
        wp db query "INSERT INTO ${TABLE_PREFIX}options (option_name, option_value, autoload) VALUES ('_helm_init_lock', '$POD_ID-$CURRENT_TIME', 'no');" >/dev/null 2>&1
        
        # Verify we actually got it
        sleep 1
        LOCK_OWNER=$(wp db query "SELECT option_value FROM ${TABLE_PREFIX}options WHERE option_name='_helm_init_lock';" --skip-column-names 2>/dev/null || echo "")
        if [[ "$LOCK_OWNER" == "$POD_ID-$CURRENT_TIME" ]]; then
          echo "Successfully claimed lock after timeout"
          break
        else
          echo "Failed to claim lock - another pod won. Exiting to avoid conflicts."
          exit 1
        fi
      fi
      
      echo "Another pod is currently running init process, waiting... (${WAIT_TIME}s/${MAX_WAIT}s)"
      sleep $CHECK_INTERVAL
      WAIT_TIME=$((WAIT_TIME + CHECK_INTERVAL))
    done

    echo "Database lock acquired, proceeding with initialization..."
    
    # ============================================================================
    # Composer Configuration
    # ============================================================================
    
    # Only initialize Composer if we have Composer packages to install
    {{- if or .Values.wordpress.plugins .Values.wordpress.themes }}
    HAS_COMPOSER_PACKAGES=false
    {{- if .Values.wordpress.plugins }}
    {{- range .Values.wordpress.plugins }}
    {{- $name := .name }}
    {{- if and (contains "/" $name) (not (hasPrefix "http://" $name)) (not (hasPrefix "https://" $name)) }}
    HAS_COMPOSER_PACKAGES=true
    {{- end }}
    {{- end }}
    {{- end }}
    {{- if .Values.wordpress.themes }}
    {{- range .Values.wordpress.themes }}
    {{- $name := .name }}
    {{- if and (contains "/" $name) (not (hasPrefix "http://" $name)) (not (hasPrefix "https://" $name)) }}
    HAS_COMPOSER_PACKAGES=true
    {{- end }}
    {{- end }}
    {{- end }}
    
    if [ "$HAS_COMPOSER_PACKAGES" = "true" ]; then
      echo "========================================="
      echo "Setting up Composer configuration..."
      echo "========================================="
      ensure_composer
      cd /var/www/html || exit 1
      
      # Track if any Composer packages were installed/updated (to run composer install later)
      COMPOSER_PACKAGES_MODIFIED=false
      
      # Initialize composer.json if it doesn't exist
      if [ ! -f composer.json ]; then
        echo "Creating composer.json..."
        cat > composer.json << COMPOSERJSON
    {
      "name": "wordpress/site",
      "description": "WordPress site managed by Helm",
      "type": "project",
      "require": {},
      "repositories": [
        {
          "type": "composer",
          "url": "https://wpackagist.org"
        }{{- if .Values.wordpress.composer.repositories }}{{- range .Values.wordpress.composer.repositories }},
        {
          "type": "{{ .type }}",
          "url": "{{ .url }}"{{- if .options }},
          "options": {{ .options | toJson }}{{- end }}
        }{{- end }}{{- end }}
      ],
      "extra": {
        "installer-paths": {
          "${WP_PLUGINS_DIR}/{\\$name}/": ["type:wordpress-plugin"],
          "${WP_THEMES_DIR}/{\\$name}/": ["type:wordpress-theme"]
        }
      },
      "config": {
        "allow-plugins": {
          "composer/installers": true
        }
      }
    }
    COMPOSERJSON
        echo "composer.json created!"
      else
        echo "composer.json already exists"
        {{- if .Values.wordpress.composer }}
        # Update repositories in existing composer.json
        echo "Updating custom repositories in composer.json..."
        
        # Build JSON array of custom repositories
        CUSTOM_REPOS='[{{- range $index, $repo := .Values.wordpress.composer.repositories }}{{- if $index }},{{- end }}{{ $repo | toJson }}{{- end }}]'
        
        # Use PHP to merge repositories (wpackagist + custom repos)
        export CUSTOM_REPOS
        TEMP_JSON=$(cat composer.json | php -r '
          $json = json_decode(file_get_contents("php://stdin"), true);
          $customReposJson = getenv("CUSTOM_REPOS");
          $customRepos = json_decode($customReposJson, true);
          
          // Remove any numeric keys that might have been added by mistake (only at top level)
          $cleanJson = [];
          foreach ($json as $key => $value) {
            if (!is_numeric($key)) {
              $cleanJson[$key] = $value;
            }
          }
          $json = $cleanJson;
          
          // Keep wpackagist repo
          $wpackagist = ["type" => "composer", "url" => "https://wpackagist.org"];
          
          // Build repositories array (wpackagist + custom repos)
          $repos = [$wpackagist];
          if (is_array($customRepos) && !empty($customRepos)) {
            foreach ($customRepos as $repo) {
              if (is_array($repo)) {
                $repos[] = $repo;
              }
            }
          }
          $json["repositories"] = $repos;
          
          // Ensure allow-plugins config is preserved/set
          if (!isset($json["config"])) {
            $json["config"] = [];
          }
          if (!isset($json["config"]["allow-plugins"])) {
            $json["config"]["allow-plugins"] = [];
          }
          $json["config"]["allow-plugins"]["composer/installers"] = true;
          
          echo json_encode($json, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
        ')
        
        echo "$TEMP_JSON" > composer.json
        echo "Custom repositories updated!"
        {{- end }}
      fi
      
      # Set allow-plugins config before requiring composer/installers
      composer config --no-plugins allow-plugins.composer/installers true
      
      # Ensure composer/installers is available for installer-paths
      if ! composer show composer/installers &>/dev/null; then
        echo "Installing composer/installers..."
        composer require composer/installers --no-interaction --quiet 2>&1 | grep -v "suggest" | grep -v "funding" || true
      fi
    fi
    {{- end }}
    
    # ============================================================================
    # WordPress Configuration (Localization, Permalinks, User Metadata)
    # ============================================================================
    
    if [ "${WP_INIT}" = "true" ]; then
        echo "========================================="
        echo "WordPress Configuration..."
        echo "========================================="
      # Set language
      if [ -n "${WP_LOCALE}" ]; then
        LANG_STATUS=$(wp language core list --language=${WP_LOCALE} --field=status)
        case $LANG_STATUS in
          "uninstalled")
            wp language core install ${WP_LOCALE} --activate
            ;;
          "installed")
            wp site switch-language ${WP_LOCALE}
            ;;
        esac
      fi

      # Set permalinks
      if [ -n "${WP_PERMALINK_STRUCTURE}" ]; then
        echo "Setting WordPress permalinks..."
        wp rewrite structure "${WP_PERMALINK_STRUCTURE}"
        wp rewrite flush
      fi

      # Set admin user metadata
      if [ -n "${WP_ADMIN_FIRSTNAME}" ]; then
        CURRENT_FIRSTNAME=$(wp user meta get "$WP_ADMIN_USER" first_name 2>/dev/null || echo "")
        if [ "$CURRENT_FIRSTNAME" != "$WP_ADMIN_FIRSTNAME" ]; then
          echo "Setting admin first name..."
          wp user meta update "$WP_ADMIN_USER" first_name "$WP_ADMIN_FIRSTNAME"
        fi
      fi
      if [ -n "${WP_ADMIN_LASTNAME}" ]; then
        CURRENT_LASTNAME=$(wp user meta get "$WP_ADMIN_USER" last_name 2>/dev/null || echo "")
        if [ "$CURRENT_LASTNAME" != "$WP_ADMIN_LASTNAME" ]; then
          echo "Setting admin last name..."
          wp user meta update "$WP_ADMIN_USER" last_name "$WP_ADMIN_LASTNAME"
        fi
      fi
    fi
    
    # ============================================================================
    # Create Custom Users
    # ============================================================================
    
    {{- if .Values.wordpress.users }}
    echo "Creating custom users..."
    EXISTING_USERS=$(wp user list --field=user_login 2>/dev/null || echo "")
    
    {{- range .Values.wordpress.users }}
    if ! echo "$EXISTING_USERS" | grep -q "^{{ .username }}$"; then
      echo "Creating user {{ .username }}..."
      run wp user create "{{ .username }}" "{{ .email }}" \
        --role="{{ .role }}" \
        --display_name="{{ .displayname }}" \
        --first_name="{{ .firstname }}" \
        --last_name="{{ .lastname }}" \
        --send-email="{{ .sendEmail }}"
    else
      echo "User {{ .username }} already exists, skipping."
    fi
    {{- end }}
    {{- else }}
    echo "No custom users specified."
    {{- end }}
    
    # ============================================================================
    # Plugin Management
    # ============================================================================
    
    # Cache all plugin data upfront for performance
    INSTALLED_PLUGINS=$(wp plugin list --field=name 2>/dev/null || echo "")
    ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
    AUTOUPDATE_ENABLED=$(wp plugin list --fields=name,auto_update --format=csv 2>/dev/null | grep ",on$" | cut -d',' -f1 || echo "")
    
    # Detect if a name is a Composer package (vendor/package format)
    # 
    # Args:
    #   $1 - Package name to check
    # 
    # Returns:
    #   0 - Is a Composer package (contains / but not URL)
    #   1 - Not a Composer package
    is_composer_package() {
      local name="$1"
      # Check if it contains / and doesn't start with http:// or https://
      if [[ "$name" == */* ]] && [[ "$name" != http://* ]] && [[ "$name" != https://* ]]; then
        return 0
      fi
      return 1
    }
    
    # Extract WordPress slug from Composer package name
    # Example: wpackagist-plugin/akismet -> akismet
    # 
    # Args:
    #   $1 - Composer package name (vendor/package)
    # 
    # Returns:
    #   Package portion after the slash
    get_composer_slug() {
      local package="$1"
      # Extract part after the /
      echo "${package##*/}"
    }

    # Handle metrics plugin
    if [ -n "${WORDPRESS_METRICS}" ]; then
      if echo "$INSTALLED_PLUGINS" | grep -q "^${WORDPRESS_METRICS}$"; then
        if ! echo "$ACTIVE_PLUGINS" | grep -q "^${WORDPRESS_METRICS}$"; then
          run wp plugin activate ${WORDPRESS_METRICS}
          ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
        fi
      else
        echo "Installing WordPress metrics plugin..."
        wp plugin install ${WORDPRESS_METRICS} --activate --force
        INSTALLED_PLUGINS=$(wp plugin list --field=name 2>/dev/null || echo "")
        ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
      fi

      echo "Flushing rewrite rules for metrics plugin..."
      run wp rewrite flush

      if ! echo "$AUTOUPDATE_ENABLED" | grep -q "^${WORDPRESS_METRICS}$"; then
        run wp plugin auto-updates enable ${WORDPRESS_METRICS}
        AUTOUPDATE_ENABLED=$(wp plugin list --fields=name,auto_update --format=csv 2>/dev/null | grep ",on$" | cut -d',' -f1 || echo "")
      fi
    else
      # Remove plugin if WORDPRESS_METRICS is empty and plugin exists
      if [ -n "${WORDPRESS_METRICS}" ] && [ -n "$INSTALLED_PLUGINS" ] && echo "$INSTALLED_PLUGINS" | grep -q "^${WORDPRESS_METRICS}$"; then
        echo "Removing metrics plugin..."
        wp plugin delete ${WORDPRESS_METRICS}
        INSTALLED_PLUGINS=$(wp plugin list --field=name 2>/dev/null || echo "")
      fi
    fi

    # ============================================================================
    # Plugin Management
    # ============================================================================
    
    # Handle custom plugins
    {{- if .Values.wordpress.plugins }}
    echo "========================================="
    echo "Installing custom plugins..."
    echo "========================================="
    
    PLUGINS_TO_INSTALL=()
    PLUGINS_TO_ACTIVATE=()
    PLUGINS_TO_AUTOUPDATE=()
    
    COMPOSER_PLUGINS_TO_INSTALL=()
    COMPOSER_PLUGINS_TO_ACTIVATE=()
    COMPOSER_PLUGINS_TO_UPDATE=()
    
    {{- range .Values.wordpress.plugins }}
    # Plugin: {{ .name }}
    PLUGIN_NAME="{{ .name }}"
    
    # Check if it's a Composer package
    if is_composer_package "$PLUGIN_NAME"; then
      echo "Detected Composer package: $PLUGIN_NAME"
      COMPOSER_SLUG=$(get_composer_slug "$PLUGIN_NAME")
      
      # Check if already installed via composer.json
      if [ -f /var/www/html/composer.json ] && grep -q "\"$PLUGIN_NAME\"" /var/www/html/composer.json 2>/dev/null; then
        echo "Composer package $PLUGIN_NAME already in composer.json"
        
        {{- if .autoupdate }}
        {{- if not .version }}
        # Auto-update only works for packages without fixed version AND already installed
        COMPOSER_PLUGINS_TO_UPDATE+=("$PLUGIN_NAME")
        {{- else }}
        echo "Note: Auto-update skipped for $PLUGIN_NAME (fixed version specified)"
        {{- end }}
        {{- end }}
      else
        {{- if .version }}
        COMPOSER_PLUGINS_TO_INSTALL+=("{{ .name }}:{{ .version }}")
        {{- else }}
        COMPOSER_PLUGINS_TO_INSTALL+=("$PLUGIN_NAME")
        {{- end }}
      fi
      
      {{- if .activate }}
      COMPOSER_PLUGINS_TO_ACTIVATE+=("$COMPOSER_SLUG")
      {{- end }}
    # Check if it's a URL (at runtime, not template time)
    elif [[ "$PLUGIN_NAME" == http://* ]] || [[ "$PLUGIN_NAME" == https://* ]]; then
      echo "Installing URL plugin: $PLUGIN_NAME"
      {{- if .activate }}
      run wp plugin install "$PLUGIN_NAME" --activate --force
      {{- else }}
      run wp plugin install "$PLUGIN_NAME" --force
      {{- end }}
      # Note: Auto-updates for URL plugins are skipped (slug cannot be reliably determined)
    else
      # Named plugin - add to batch processing
      if ! echo "$INSTALLED_PLUGINS" | grep -q "^${PLUGIN_NAME}$"; then
        {{- if .version }}
        PLUGINS_TO_INSTALL+=("{{ .name }}:{{ .version }}")
        {{- else }}
        PLUGINS_TO_INSTALL+=("{{ .name }}")
        {{- end }}
      fi
      {{- if .activate }}
      PLUGINS_TO_ACTIVATE+=("{{ .name }}")
      {{- end }}
      {{- if .autoupdate }}
      PLUGINS_TO_AUTOUPDATE+=("{{ .name }}")
      {{- end }}
    fi
    {{- end }}

    # Batch install plugins
    if [ ${#PLUGINS_TO_INSTALL[@]} -gt 0 ]; then
      echo "Installing ${#PLUGINS_TO_INSTALL[@]} plugin(s)..."
      
      PLUGINS_NO_VERSION=()
      PLUGINS_WITH_VERSION=()
      
      for plugin_spec in "${PLUGINS_TO_INSTALL[@]}"; do
        if [[ "$plugin_spec" == *":"* ]]; then
          PLUGINS_WITH_VERSION+=("$plugin_spec")
        else
          PLUGINS_NO_VERSION+=("$plugin_spec")
        fi
      done
      
      if [ ${#PLUGINS_NO_VERSION[@]} -gt 0 ]; then
        wp plugin install "${PLUGINS_NO_VERSION[@]}" --force
      fi
      
      for plugin_spec in "${PLUGINS_WITH_VERSION[@]}"; do
        PLUGIN_NAME="${plugin_spec%%:*}"
        PLUGIN_VERSION="${plugin_spec##*:}"
        wp plugin install "${PLUGIN_NAME}" --version="${PLUGIN_VERSION}" --force
      done
      
      INSTALLED_PLUGINS=$(wp plugin list --field=name 2>/dev/null || echo "")
      ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
    fi
    
    # Install Composer plugins
    if [ ${#COMPOSER_PLUGINS_TO_INSTALL[@]} -gt 0 ]; then
      echo "Installing ${#COMPOSER_PLUGINS_TO_INSTALL[@]} Composer plugin(s)..."
      cd /var/www/html || exit 1
      
      for package_spec in "${COMPOSER_PLUGINS_TO_INSTALL[@]}"; do
        echo "Installing Composer package: $package_spec"
        # Capture output and only show on error
        if ! COMPOSER_OUTPUT=$(composer require "$package_spec" --no-interaction 2>&1); then
          echo "$COMPOSER_OUTPUT"
          echo "Error installing Composer package: $package_spec"
          exit 1
        fi
      done
      
      echo "Composer plugins installed!"
      COMPOSER_PACKAGES_MODIFIED=true
      INSTALLED_PLUGINS=$(wp plugin list --field=name 2>/dev/null || echo "")
      ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
    fi
    
    # Update Composer plugins (auto-update for packages without fixed version)
    if [ ${#COMPOSER_PLUGINS_TO_UPDATE[@]} -gt 0 ]; then
      echo "Updating ${#COMPOSER_PLUGINS_TO_UPDATE[@]} Composer plugin(s)..."
      cd /var/www/html || exit 1
      
      for package in "${COMPOSER_PLUGINS_TO_UPDATE[@]}"; do
        echo "Updating Composer package: $package"
        # Capture output and only show on error
        if ! COMPOSER_OUTPUT=$(composer update "$package" --no-interaction 2>&1); then
          echo "$COMPOSER_OUTPUT"
          echo "Error updating Composer package: $package"
          exit 1
        fi
      done
      
      echo "Composer plugins updated!"
      COMPOSER_PACKAGES_MODIFIED=true
    fi

    # Install all Composer dependencies will be done after themes processing

    # Batch activate plugins
    if [ ${#PLUGINS_TO_ACTIVATE[@]} -gt 0 ]; then
      PLUGINS_NEED_ACTIVATION=()
      for plugin in "${PLUGINS_TO_ACTIVATE[@]}"; do
        if ! echo "$ACTIVE_PLUGINS" | grep -q "^${plugin}$"; then
          PLUGINS_NEED_ACTIVATION+=("$plugin")
        fi
      done
      
      if [ ${#PLUGINS_NEED_ACTIVATION[@]} -gt 0 ]; then
        echo "Activating ${#PLUGINS_NEED_ACTIVATION[@]} plugin(s)..."
        run wp plugin activate "${PLUGINS_NEED_ACTIVATION[@]}"
        ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
      fi
    fi
    
    # Activate Composer plugins
    if [ ${#COMPOSER_PLUGINS_TO_ACTIVATE[@]} -gt 0 ]; then
      COMPOSER_PLUGINS_NEED_ACTIVATION=()
      for plugin in "${COMPOSER_PLUGINS_TO_ACTIVATE[@]}"; do
        if ! echo "$ACTIVE_PLUGINS" | grep -q "^${plugin}$"; then
          COMPOSER_PLUGINS_NEED_ACTIVATION+=("$plugin")
        fi
      done
      
      if [ ${#COMPOSER_PLUGINS_NEED_ACTIVATION[@]} -gt 0 ]; then
        echo "Activating ${#COMPOSER_PLUGINS_NEED_ACTIVATION[@]} Composer plugin(s)..."
        run wp plugin activate "${COMPOSER_PLUGINS_NEED_ACTIVATION[@]}"
        ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
      fi
    fi

    # Batch enable auto-updates
    if [ ${#PLUGINS_TO_AUTOUPDATE[@]} -gt 0 ]; then
      PLUGINS_NEED_AUTOUPDATE=()
      for plugin in "${PLUGINS_TO_AUTOUPDATE[@]}"; do
        if ! echo "$AUTOUPDATE_ENABLED" | grep -q "^${plugin}$"; then
          PLUGINS_NEED_AUTOUPDATE+=("$plugin")
        fi
      done
      
      if [ ${#PLUGINS_NEED_AUTOUPDATE[@]} -gt 0 ]; then
        echo "Enabling auto-updates for ${#PLUGINS_NEED_AUTOUPDATE[@]} plugin(s)..."
        run wp plugin auto-updates enable "${PLUGINS_NEED_AUTOUPDATE[@]}"
      fi
    fi
    {{- else }}
    echo "No custom plugins specified."
    {{- end }}

    {{- if .Values.wordpress.pluginsPrune }}
    # ============================================================================
    # Plugin Pruning - Remove plugins not in the defined list
    # ============================================================================
    
    # Build comma-separated list of plugins to exclude from deletion
    EXCLUDE_PLUGINS=""
    COMPOSER_PACKAGES_TO_KEEP=()
    COMPOSER_THEME_PACKAGES_TO_KEEP=()
    {{- if .Values.wordpress.plugins }}
    {{- range $index, $plugin := .Values.wordpress.plugins }}
    PLUGIN_NAME="{{ $plugin.name }}"
    if is_composer_package "$PLUGIN_NAME"; then
      # Track Composer packages separately
      COMPOSER_PACKAGES_TO_KEEP+=("$PLUGIN_NAME")
    else
      # Add to regular exclude list
      {{- if eq $index 0 }}
      EXCLUDE_PLUGINS="{{ $plugin.name }}"
      {{- else }}
      EXCLUDE_PLUGINS="${EXCLUDE_PLUGINS},{{ $plugin.name }}"
      {{- end }}
    fi
    {{- end }}
    {{- end }}
    {{- if .Values.wordpress.themes }}
    {{- range .Values.wordpress.themes }}
    THEME_NAME="{{ .name }}"
    if is_composer_package "$THEME_NAME"; then
      # Track Composer theme packages separately
      COMPOSER_THEME_PACKAGES_TO_KEEP+=("$THEME_NAME")
    fi
    {{- end }}
    {{- end }}
    {{- if .Values.metrics.wordpress.enabled }}
    {{- if .Values.metrics.wordpress.installPlugin }}
    {{- if .Values.metrics.wordpress.pluginNameOverride }}
    [ -n "$EXCLUDE_PLUGINS" ] && EXCLUDE_PLUGINS="${EXCLUDE_PLUGINS},{{ .Values.metrics.wordpress.pluginNameOverride }}" || EXCLUDE_PLUGINS="{{ .Values.metrics.wordpress.pluginNameOverride }}"
    {{- else }}
    [ -n "$EXCLUDE_PLUGINS" ] && EXCLUDE_PLUGINS="${EXCLUDE_PLUGINS},slymetrics" || EXCLUDE_PLUGINS="slymetrics"
    {{- end }}
    {{- end }}
    {{- end }}
    
    # Delete all plugins except those in the exclude list
    if [ -n "$EXCLUDE_PLUGINS" ]; then
      echo "Pruning plugins not in the defined list..."
      echo "Keeping plugins: $EXCLUDE_PLUGINS"
      run wp plugin delete --all --exclude="$EXCLUDE_PLUGINS"
    else
      echo "Pruning plugins not in the defined list..."
      echo "Deleting all plugins..."
      run wp plugin delete --all
    fi
    {{- end }}
    
    # ============================================================================
    # Theme Management
    # ============================================================================
    
    {{- if .Values.wordpress.themes }}
    echo "========================================="
    echo "Installing custom themes..."
    echo "========================================="
    
    # Cache all theme data upfront
    INSTALLED_THEMES=$(wp theme list --field=name 2>/dev/null || echo "")
    ACTIVE_THEME=$(wp theme list --status=active --field=name 2>/dev/null || echo "")
    AUTOUPDATE_ENABLED_THEMES=$(wp theme list --fields=name,auto_update --format=csv 2>/dev/null | grep ",on$" | cut -d',' -f1 || echo "")
    
    # Extract theme slug from name/URL
    get_theme_slug() {
      local theme_name="$1"
      if [[ "$theme_name" == *".zip" ]]; then
        basename "$theme_name" .zip
      else
        echo "$theme_name"
      fi
    }
    
    THEMES_TO_INSTALL=()
    THEME_TO_ACTIVATE=""
    THEMES_TO_AUTOUPDATE=()
    
    COMPOSER_THEMES_TO_INSTALL=()
    COMPOSER_THEME_TO_ACTIVATE=""
    COMPOSER_THEMES_TO_UPDATE=()
    
    {{- range .Values.wordpress.themes }}
    THEME_NAME="{{ .name }}"
    
    # Check if it's a Composer package
    if is_composer_package "$THEME_NAME"; then
      echo "Detected Composer theme package: $THEME_NAME"
      COMPOSER_THEME_SLUG=$(get_composer_slug "$THEME_NAME")
      
      # Check if already installed via composer.json
      if [ -f /var/www/html/composer.json ] && grep -q "\"$THEME_NAME\"" /var/www/html/composer.json 2>/dev/null; then
        echo "Composer theme package $THEME_NAME already in composer.json"
        
        {{- if .autoupdate }}
        {{- if not .version }}
        # Auto-update only works for packages without fixed version AND already installed
        COMPOSER_THEMES_TO_UPDATE+=("$THEME_NAME")
        {{- else }}
        echo "Note: Auto-update skipped for theme $THEME_NAME (fixed version specified)"
        {{- end }}
        {{- end }}
      else
        {{- if .version }}
        COMPOSER_THEMES_TO_INSTALL+=("{{ .name }}:{{ .version }}")
        {{- else }}
        COMPOSER_THEMES_TO_INSTALL+=("$THEME_NAME")
        {{- end }}
      fi
      
      {{- if .activate }}
      COMPOSER_THEME_TO_ACTIVATE="$COMPOSER_THEME_SLUG"
      {{- end }}
    else
      THEME_SLUG=$(get_theme_slug "{{ .name }}")

      if ! echo "$INSTALLED_THEMES" | grep -q "^${THEME_SLUG}$"; then
        {{- if .version }}
        THEMES_TO_INSTALL+=("{{ .name }}:{{ .version }}")
        {{- else }}
        THEMES_TO_INSTALL+=("{{ .name }}")
        {{- end }}
      fi
      {{- if .activate }}
      THEME_TO_ACTIVATE="${THEME_SLUG}"
      {{- end }}
      {{- if .autoupdate }}
      THEMES_TO_AUTOUPDATE+=("${THEME_SLUG}")
      {{- end }}
    fi
    {{- end }}

    # Batch install themes
    if [ ${#THEMES_TO_INSTALL[@]} -gt 0 ]; then
      echo "Installing ${#THEMES_TO_INSTALL[@]} theme(s)..."
      
      THEMES_SIMPLE=()
      THEMES_URLS=()
      THEMES_WITH_VERSION=()
      
      for theme_spec in "${THEMES_TO_INSTALL[@]}"; do
        if [[ "$theme_spec" == http://* ]] || [[ "$theme_spec" == https://* ]]; then
          THEMES_URLS+=("$theme_spec")
        elif [[ "$theme_spec" == *":"* ]]; then
          THEMES_WITH_VERSION+=("$theme_spec")
        else
          THEMES_SIMPLE+=("$theme_spec")
        fi
      done
      
      if [ ${#THEMES_SIMPLE[@]} -gt 0 ]; then
        wp theme install "${THEMES_SIMPLE[@]}" --force
      fi
      
      for theme_url in "${THEMES_URLS[@]}"; do
        echo "Installing theme from URL: $theme_url"
        wp theme install "$theme_url" --force
      done
      
      for theme_spec in "${THEMES_WITH_VERSION[@]}"; do
        THEME_NAME="${theme_spec%%:*}"
        THEME_VERSION="${theme_spec##*:}"
        echo "Installing theme ${THEME_NAME} version ${THEME_VERSION}..."
        wp theme install "${THEME_NAME}" --version="${THEME_VERSION}" --force
      done
      
      INSTALLED_THEMES=$(wp theme list --field=name 2>/dev/null || echo "")
      ACTIVE_THEME=$(wp theme list --status=active --field=name 2>/dev/null || echo "")
    fi
    
    # Install Composer themes
    if [ ${#COMPOSER_THEMES_TO_INSTALL[@]} -gt 0 ]; then
      echo "Installing ${#COMPOSER_THEMES_TO_INSTALL[@]} Composer theme(s)..."
      cd /var/www/html || exit 1
      
      for package_spec in "${COMPOSER_THEMES_TO_INSTALL[@]}"; do
        echo "Installing Composer theme package: $package_spec"
        # Capture output and only show on error
        if ! COMPOSER_OUTPUT=$(composer require "$package_spec" --no-interaction 2>&1); then
          echo "$COMPOSER_OUTPUT"
          echo "Error installing Composer theme package: $package_spec"
          exit 1
        fi
      done
      
      echo "Composer themes installed!"
      COMPOSER_PACKAGES_MODIFIED=true
      INSTALLED_THEMES=$(wp theme list --field=name 2>/dev/null || echo "")
      ACTIVE_THEME=$(wp theme list --status=active --field=name 2>/dev/null || echo "")
    fi
    
    # Update Composer themes (auto-update for packages without fixed version)
    if [ ${#COMPOSER_THEMES_TO_UPDATE[@]} -gt 0 ]; then
      echo "Updating ${#COMPOSER_THEMES_TO_UPDATE[@]} Composer theme(s)..."
      cd /var/www/html || exit 1
      
      for package in "${COMPOSER_THEMES_TO_UPDATE[@]}"; do
        echo "Updating Composer theme package: $package"
        # Capture output and only show on error
        if ! COMPOSER_OUTPUT=$(composer update "$package" --no-interaction 2>&1); then
          echo "$COMPOSER_OUTPUT"
          echo "Error updating Composer theme package: $package"
          exit 1
        fi
      done
      
      echo "Composer themes updated!"
      COMPOSER_PACKAGES_MODIFIED=true
    fi

    # Activate theme
    if [ -n "$THEME_TO_ACTIVATE" ] && [ "$ACTIVE_THEME" != "$THEME_TO_ACTIVATE" ]; then
      echo "Activating theme: $THEME_TO_ACTIVATE"
      run wp theme activate "$THEME_TO_ACTIVATE"
    fi
    
    # Activate Composer theme
    if [ -n "$COMPOSER_THEME_TO_ACTIVATE" ] && [ "$ACTIVE_THEME" != "$COMPOSER_THEME_TO_ACTIVATE" ]; then
      echo "Activating Composer theme: $COMPOSER_THEME_TO_ACTIVATE"
      run wp theme activate "$COMPOSER_THEME_TO_ACTIVATE"
    fi

    # Batch enable auto-updates
    if [ ${#THEMES_TO_AUTOUPDATE[@]} -gt 0 ]; then
      THEMES_NEED_AUTOUPDATE=()
      for theme in "${THEMES_TO_AUTOUPDATE[@]}"; do
        if ! echo "$AUTOUPDATE_ENABLED_THEMES" | grep -q "^${theme}$"; then
          THEMES_NEED_AUTOUPDATE+=("$theme")
        fi
      done
      
      if [ ${#THEMES_NEED_AUTOUPDATE[@]} -gt 0 ]; then
        echo "Enabling auto-updates for ${#THEMES_NEED_AUTOUPDATE[@]} theme(s)..."
        run wp theme auto-updates enable "${THEMES_NEED_AUTOUPDATE[@]}"
      fi
    fi
    {{- else }}
    echo "No custom themes specified."
    {{- end }}

    {{- if .Values.wordpress.themesPrune }}
    # ============================================================================
    # Theme Pruning - Remove themes not in the defined list
    # ============================================================================
    
    # Build list of theme slugs to keep
    THEMES_TO_KEEP=()
    {{- if .Values.wordpress.themes }}
    {{- range .Values.wordpress.themes }}
    THEME_NAME="{{ .name }}"
    if is_composer_package "$THEME_NAME"; then
      # Extract theme slug from Composer package name (e.g., wpackagist-theme/astra -> astra)
      THEME_SLUG=$(echo "$THEME_NAME" | sed 's/.*\///')
      THEMES_TO_KEEP+=("$THEME_SLUG")
    else
      THEME_SLUG=$(get_theme_slug "{{ .name }}")
      THEMES_TO_KEEP+=("$THEME_SLUG")
    fi
    {{- end }}
    {{- end }}
    
    # Get all installed themes and active theme
    INSTALLED_THEMES=$(wp theme list --field=name 2>/dev/null || echo "")
    ACTIVE_THEME=$(wp theme list --status=active --field=name 2>/dev/null || echo "")
    
    # Build list of themes to delete (installed themes minus keep list minus active theme)
    THEMES_TO_DELETE=()
    for theme in $INSTALLED_THEMES; do
      # Safety: Never delete the active theme
      if [ "$theme" = "$ACTIVE_THEME" ]; then
        continue
      fi
      
      # Check if theme is in the keep list
      KEEP=false
      for keep_theme in "${THEMES_TO_KEEP[@]}"; do
        if [ "$theme" = "$keep_theme" ]; then
          KEEP=true
          break
        fi
      done
      
      if [ "$KEEP" = false ]; then
        THEMES_TO_DELETE+=("$theme")
      fi
    done
    
    # Delete all themes in one command for better performance
    if [ ${#THEMES_TO_DELETE[@]} -gt 0 ]; then
      echo "Pruning themes not in the defined list..."
      echo "Keeping active theme: $ACTIVE_THEME"
      echo "Removing ${#THEMES_TO_DELETE[@]} theme(s): ${THEMES_TO_DELETE[*]}"
      run wp theme delete "${THEMES_TO_DELETE[@]}"
    fi
    
    # Remove Composer packages (plugins & themes) not in the keep lists
    if [ -f /var/www/html/composer.json ]; then
      cd /var/www/html || exit 1
      
      # Get all currently required packages from composer.json (excluding composer/installers)
      # Use jq for reliable JSON parsing instead of sed
      CURRENT_PACKAGES=$(cat composer.json | php -r '
        $json = json_decode(file_get_contents("php://stdin"), true);
        if (isset($json["require"])) {
          foreach ($json["require"] as $package => $version) {
            if ($package !== "composer/installers") {
              echo $package . "\n";
            }
          }
        }
      ' || echo "")
      
      # Track packages that should be removed
      PACKAGES_TO_REMOVE=()
      
      for package in $CURRENT_PACKAGES; do
        KEEP=false
        
        # Check if it's in the plugin keep list
        for keep_package in "${COMPOSER_PACKAGES_TO_KEEP[@]}"; do
          if [ "$package" = "$keep_package" ]; then
            KEEP=true
            break
          fi
        done
        
        # If not found in plugins, check theme keep list
        if [ "$KEEP" = false ]; then
          for keep_package in "${COMPOSER_THEME_PACKAGES_TO_KEEP[@]}"; do
            if [ "$package" = "$keep_package" ]; then
              KEEP=true
              break
            fi
          done
        fi
        
        if [ "$KEEP" = false ]; then
          PACKAGES_TO_REMOVE+=("$package")
        fi
      done
      
      # Remove all packages in one go
      if [ ${#PACKAGES_TO_REMOVE[@]} -gt 0 ]; then
        echo "========================================="
        echo "Pruning Composer packages..."
        echo "========================================="
        echo "Removing ${#PACKAGES_TO_REMOVE[@]} Composer package(s): ${PACKAGES_TO_REMOVE[*]}"
        for package in "${PACKAGES_TO_REMOVE[@]}"; do
          echo "Removing: $package"
          if ! COMPOSER_OUTPUT=$(composer remove "$package" --no-interaction --quiet 2>&1); then
            echo "$COMPOSER_OUTPUT"
            echo "Error removing Composer package: $package"
          fi
        done
        echo "Composer packages pruned successfully!"
      fi
    fi
    {{- end }}

    # Install all Composer dependencies once after all packages are installed/updated
    # This ensures packages like s3-uploads get their dependencies (e.g., AWS SDK)
    if [ "$COMPOSER_PACKAGES_MODIFIED" = "true" ]; then
      echo ""
      echo "========================================="
      echo "Installing Composer dependencies..."
      echo "========================================="
      cd /var/www/html || exit 1
      if ! COMPOSER_OUTPUT=$(composer install --no-interaction 2>&1 | grep -v "suggest" | grep -v "funding"); then
        echo "$COMPOSER_OUTPUT"
        echo "Error installing Composer dependencies"
        exit 1
      fi
      echo "Composer dependencies installed!"
      
      # Also run composer install in each plugin/theme directory that has a composer.json
      # This is needed for packages like humanmade/s3-uploads that require their own vendor directory
      echo "Installing plugin-specific Composer dependencies..."
      for plugin_dir in ${WP_PLUGINS_DIR}/*/; do
        if [ -f "${plugin_dir}composer.json" ]; then
          PLUGIN_NAME=$(basename "$plugin_dir")
          echo "Running composer install in plugin: $PLUGIN_NAME"
          cd "$plugin_dir" || continue
          if composer install --no-dev --no-interaction --ignore-platform-reqs --quiet 2>&1 | grep -E "Error|Warning|Failed" > /tmp/composer-error.txt; then
            cat /tmp/composer-error.txt
            echo "Warning: Could not install dependencies for plugin: $PLUGIN_NAME"
          else
            echo "Successfully installed dependencies for plugin: $PLUGIN_NAME"
          fi
          cd /var/www/html || handle_error "Cannot return to WordPress root directory"
        fi
      done
      
      echo "Installing theme-specific Composer dependencies..."
      for theme_dir in ${WP_THEMES_DIR}/*/; do
        if [ -f "${theme_dir}composer.json" ]; then
          THEME_NAME=$(basename "$theme_dir")
          echo "Running composer install in theme: $THEME_NAME"
          cd "$theme_dir" || continue
          if composer install --no-dev --no-interaction --ignore-platform-reqs --quiet 2>&1 | grep -E "Error|Warning|Failed" > /tmp/composer-error.txt; then
            cat /tmp/composer-error.txt
            echo "Warning: Could not install dependencies for theme: $THEME_NAME"
          else
            echo "Successfully installed dependencies for theme: $THEME_NAME"
          fi
          cd /var/www/html || handle_error "Cannot return to WordPress root directory"
        fi
      done
      
      # Create MU-Plugin to auto-load Composer autoloaders from plugins/themes
      # This ensures dependencies like AWS SDK are available to plugins
      echo "Creating MU-Plugin for Composer autoloader support..."
      mkdir -p "${WP_MU_PLUGINS_DIR}"
      cat > "${WP_MU_PLUGINS_DIR}/composer-autoloader.php" << 'MUEOF'
    <?php
    /**
     * Plugin Name: Composer Autoloader
     * Description: Automatically loads Composer autoloaders from plugins and themes
     * Author: Helm Chart
     * Version: 1.0.0
     */
    
    // Load Composer autoloaders from all plugins
    foreach ( glob( WP_CONTENT_DIR . '/plugins/*/vendor/autoload.php' ) as $autoloader ) {
    	require_once $autoloader;
    }
    
    // Load Composer autoloaders from all themes
    foreach ( glob( WP_CONTENT_DIR . '/themes/*/vendor/autoload.php' ) as $autoloader ) {
    	require_once $autoloader;
    }
    MUEOF
      echo "Composer autoloader MU-Plugin created!"
    fi

    echo "WordPress initialization completed!"
    
    # ============================================================================
    # Custom Init Commands
    # ============================================================================
    {{- if .Values.wordpress.init.customInitConfigMap.name }}
    
    echo "Running custom init commands from ConfigMap..."
    echo "========================================="
    if [ -f /tmp/custom-init-commands/{{ .Values.wordpress.init.customInitConfigMap.key | default "commands.sh" }} ]; then
      # Execute the custom commands script (already executable via defaultMode: 0755)
      /tmp/custom-init-commands/{{ .Values.wordpress.init.customInitConfigMap.key | default "commands.sh" }}
      echo "========================================="
      echo "Custom init commands completed!"
    else
      echo "Warning: Custom commands file not found in ConfigMap"
    fi
    {{- else }}
    echo "No custom init commands configured."
    {{- end }}
    
    # ============================================================================
    # Release Lock and Complete
    # ============================================================================
    
    # Lock will be released automatically via trap on EXIT
    echo "Init script completed!"