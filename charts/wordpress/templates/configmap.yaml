{{- if or (not .Values.apache.customDefaultSiteConfigMap) (not .Values.apache.customPortsConfigMap) (not .Values.apache.customPhpConfigMap) (not .Values.wordpress.htaccessConfigMap)  }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "wordpress.fullname" . }}-configfiles
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "wordpress.labels" . | nindent 4 }}
data:
  {{- if (not .Values.apache.customDefaultSiteConfigMap)  }}
  000-default.conf: |
    {{- if .Values.apache.customDefaultSiteConfig }}
    {{ .Values.apache.customDefaultSiteConfig | nindent 4 }}
    {{- else if .Values.metrics.apache.enabled }}
    <VirtualHost *:{{ .Values.service.ports.http }}>
            ServerAdmin webmaster@localhost
            <Location "/server-status">
                    SetHandler server-status
                    Require local
            </Location>
            DocumentRoot /var/www/html
            ErrorLog ${APACHE_LOG_DIR}/error.log
            CustomLog ${APACHE_LOG_DIR}/access.log combined
    </VirtualHost>
    {{- else }}
    <VirtualHost *:{{ .Values.service.ports.http }}>
            ServerAdmin webmaster@localhost
            DocumentRoot /var/www/html

            ErrorLog ${APACHE_LOG_DIR}/error.log
            CustomLog ${APACHE_LOG_DIR}/access.log combined
    </VirtualHost>
    {{- end }}
  {{- end }}
  {{- if (not .Values.apache.customPortsConfigMap) }}
  ports.conf: |
    {{- if .Values.apache.customPortsConfig }}
    {{ .Values.apache.customPortsConfig | nindent 4 }}
    {{- else }}
    Listen {{ .Values.service.ports.http }}
    {{- end }}
  {{- end }}
  {{- if (not .Values.apache.customPhpConfigMap) }}
  custom.ini: |
    {{- if and .Values.apache.customPhpConfig  (not .Values.apache.customPhpConfigMap) }}
    {{ .Values.apache.customPhpConfig | nindent 4 }}
    {{- end }}
  {{- end }}
  {{- if (not .Values.wordpress.htaccessConfigMap) }}
  htaccess: |
    {{- if and .Values.wordpress.htaccess  (not .Values.wordpress.htaccessConfigMap) }}
    {{ .Values.wordpress.htaccess | nindent 4 }}
    {{ else if .Values.metrics.apache.enabled }}
    # Server-status exception
    <IfModule mod_rewrite.c>
    RewriteRule ^server-status - [L]
    </IfModule>

    # BEGIN WordPress
    # The directives (lines) between "BEGIN WordPress" and "END WordPress" are
    # dynamically generated and will be automatically injected by the init container.
    # Any changes to the directives between these markers will be overwritten.
    # END WordPress
    {{ else }}
    # BEGIN WordPress
    # The directives (lines) between "BEGIN WordPress" and "END WordPress" are
    # dynamically generated and will be automatically injected by the init container.
    # Any changes to the directives between these markers will be overwritten.
    # END WordPress
    {{- end }}
  {{- end }}
{{- end }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "wordpress.fullname" . }}-init
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "wordpress.labels" . | nindent 4 }}
data:
  base.sh: |
    #!/bin/bash

    # Helper function to extract WordPress version from version.php
    get_wp_version() {
      local version_file="$1"
      if [ -f "$version_file" ]; then
        grep "^\$wp_version" "$version_file" | sed "s/.*'\([^']*\)'.*/\1/"
      else
        echo ""
      fi
    }

    # Helper function to copy WordPress core files (excludes wp-content)
    copy_wp_core() {
      echo "Copying WordPress core files..."
      cd /usr/src/wordpress || exit 1
      for item in *; do
        if [ "$item" != "wp-content" ]; then
          cp -r "$item" /tmp/wordpress/ || exit 1
        fi
      done
      echo "WordPress core files copied successfully!"
    }

    # Get versions from image and PVC
    IMAGE_VERSION=$(get_wp_version "/usr/src/wordpress/wp-includes/version.php")
    PVC_VERSION=$(get_wp_version "/tmp/wordpress/wp-includes/version.php")

    echo "========================================="
    echo "WordPress Version Check"
    echo "========================================="
    echo "Image version: ${IMAGE_VERSION:-'not found'}"
    echo "PVC version:   ${PVC_VERSION:-'not installed'}"
    echo "========================================="

    # Check if WordPress needs to be installed or updated
    if [ -z "$PVC_VERSION" ]; then
        echo "WordPress not found in /tmp/wordpress - fresh installation..."
        mkdir -p /tmp/wordpress
        copy_wp_core

        # Handle wp-config-docker.php for fresh install
        if [ -f "/usr/src/wordpress/wp-config-docker.php" ] && [ ! -s /tmp/wordpress/wp-config.php ]; then
          awk '
            /put your unique phrase here/ {
              cmd = "head -c1m /dev/urandom | sha1sum | cut -d\\  -f1"
              cmd | getline str
              close(cmd)
              gsub("put your unique phrase here", str)
            }
            { print }
          ' /usr/src/wordpress/wp-config-docker.php > /tmp/wordpress/wp-config.php
        fi

        # Copy wp-content skeleton if not present
        if [ ! -d /tmp/wordpress/wp-content ]; then
            cp -r /usr/src/wordpress/wp-content /tmp/wordpress/wp-content 2>/dev/null || true
        fi
        echo "Complete! WordPress has been successfully installed to /tmp/wordpress"

    elif [ "$IMAGE_VERSION" != "$PVC_VERSION" ]; then
        echo "WordPress version mismatch detected!"
        echo "Updating core files from $PVC_VERSION to $IMAGE_VERSION..."
        echo "Note: wp-content directory will be preserved."
        copy_wp_core
        echo "Complete! WordPress core has been updated to $IMAGE_VERSION"

        # Mark that a core update happened (used by init.sh to disable auto-updates)
        touch /tmp/wordpress/.wp-core-updated

    else
        echo "WordPress version matches - no update needed."
    fi

    # ============================================================================
    # Setup MU-Plugins from ConfigMaps
    # ============================================================================
    {{- if .Values.wordpress.muPluginsConfigMaps }}
    echo ""
    echo "Setting up MU-Plugins from ConfigMaps..."
    echo "========================================="

    # Create mu-plugins directory if it doesn't exist
    mkdir -p /tmp/wordpress/wp-content/mu-plugins
    chown www-data:www-data /tmp/wordpress/wp-content/mu-plugins
    chmod 755 /tmp/wordpress/wp-content/mu-plugins

    {{- range .Values.wordpress.muPluginsConfigMaps }}
    # Copy files from ConfigMap: {{ .name }}
    if [ -d "/tmp/mu-plugins-{{ .name }}" ]; then
      {{- if .key }}
      # Copy specific key only
      if [ -f "/tmp/mu-plugins-{{ .name }}/{{ .key }}" ]; then
        echo "Copying MU-Plugin file {{ .key }} from {{ .name }}..."
        cp /tmp/mu-plugins-{{ .name }}/{{ .key }} /tmp/wordpress/wp-content/mu-plugins/
        chown www-data:www-data /tmp/wordpress/wp-content/mu-plugins/{{ .key }}
        chmod 644 /tmp/wordpress/wp-content/mu-plugins/{{ .key }}
        echo "MU-Plugin file {{ .key }} from {{ .name }} copied successfully!"
      else
        echo "Warning: Key {{ .key }} not found in ConfigMap {{ .name }}"
      fi
      {{- else }}
      # Copy all files from ConfigMap
      echo "Copying all MU-Plugin files from {{ .name }}..."
      cp -r -L /tmp/mu-plugins-{{ .name }}/* /tmp/wordpress/wp-content/mu-plugins/ 2>/dev/null || true
      # Set correct ownership and permissions for all copied files
      find /tmp/wordpress/wp-content/mu-plugins -type f -exec chown www-data:www-data {} \;
      find /tmp/wordpress/wp-content/mu-plugins -type f -exec chmod 644 {} \;
      echo "MU-Plugin files from {{ .name }} copied successfully!"
      {{- end }}
    else
      echo "Warning: MU-Plugin ConfigMap mount {{ .name }} not found"
    fi
    {{- end }}

    echo "MU-Plugins setup completed!"
    {{- else }}
    echo "No MU-Plugins ConfigMaps configured."
    {{- end }}

    # ============================================================================
    # Custom Init Commands ConfigMap Info
    # ============================================================================
    {{- if .Values.wordpress.init.customInitConfigMap.name }}
    echo ""
    echo "Custom init commands ConfigMap detected: {{ .Values.wordpress.init.customInitConfigMap.name }}"
    {{- end }}

    echo "========================================="
    echo "Base script completed!"
    echo "========================================="
  htaccess-setup.sh: |
    #!/bin/sh
    # Script to setup .htaccess on persistent volume
    # This runs in the base init container

    echo "Starting .htaccess setup..."

    # Copy and make injection script executable once
    cp /scripts/htaccess-inject.sh /tmp/htaccess-inject.sh
    chmod +x /tmp/htaccess-inject.sh

    # Check if .htaccess already exists on persistent volume
    if [ ! -f /tmp/wordpress/.htaccess ]; then
      echo ".htaccess not found on persistent volume, creating from ConfigMap..."

      # Copy .htaccess from ConfigMap and inject WordPress rules
      /tmp/htaccess-inject.sh \
        /configfiles/.htaccess \
        /tmp/wordpress/.htaccess \
        /scripts/wordpress-rewrite-rules.txt

      # Set correct ownership and permissions
      chown www-data:www-data /tmp/wordpress/.htaccess
      chmod 664 /tmp/wordpress/.htaccess
      echo "WordPress rewrite rules successfully injected and written to persistent volume!"
    else
      echo ".htaccess already exists on persistent volume."

      # Extract WordPress block content from existing file (if it exists)
      if grep -q "# BEGIN WordPress" /tmp/wordpress/.htaccess; then
        echo "Extracting WordPress block content from existing .htaccess..."

        # Extract ONLY the content between markers (excluding the markers themselves)
        awk '/# BEGIN WordPress/,/# END WordPress/{if (!/# BEGIN WordPress/ && !/# END WordPress/) print}' /tmp/wordpress/.htaccess > /tmp/wp-block-content.txt

        # Start with fresh ConfigMap .htaccess and inject the existing WordPress block content
        /tmp/htaccess-inject.sh \
          /configfiles/.htaccess \
          /tmp/htaccess-new \
          /tmp/wp-block-content.txt

        # Replace old .htaccess with updated one
        mv /tmp/htaccess-new /tmp/wordpress/.htaccess
        chown www-data:www-data /tmp/wordpress/.htaccess
        chmod 664 /tmp/wordpress/.htaccess
        echo "ConfigMap .htaccess updated with existing WordPress block content!"
      else
        echo "No WordPress block found in existing .htaccess."

        # Inject default WordPress rules into fresh ConfigMap .htaccess
          /tmp/htaccess-inject.sh \
            /configfiles/.htaccess \
            /tmp/htaccess-new \
            /scripts/wordpress-rewrite-rules.txt        # Replace old .htaccess with updated one
        mv /tmp/htaccess-new /tmp/wordpress/.htaccess
        chown www-data:www-data /tmp/wordpress/.htaccess
        chmod 664 /tmp/wordpress/.htaccess
        echo "ConfigMap .htaccess applied with default WordPress rules!"
      fi
    fi

    echo "========================================="
    echo ".htaccess setup completed!"
    echo "========================================="
  wordpress-rewrite-rules.txt: |
    <IfModule mod_rewrite.c>
    RewriteEngine On
    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
    RewriteBase /
    RewriteRule ^index\.php$ - [L]
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteRule . /index.php [L]
    </IfModule>
  htaccess-inject.sh: |
    #!/bin/sh
    # Script to inject WordPress rewrite rules into .htaccess
    # Usage: htaccess-inject.sh <source-htaccess> <output-htaccess> <rules-file>

    SOURCE_FILE="$1"
    OUTPUT_FILE="$2"
    RULES_FILE="$3"

    awk -v rules_file="$RULES_FILE" '
    BEGIN {
        in_wp=0
        wp_done=0
        # Read rules from file
        while ((getline line < rules_file) > 0) {
            rules = rules line "\n"
        }
        close(rules_file)
    }
    /# BEGIN WordPress/ {
        print
        printf "%s", rules
        in_wp=1
        wp_done=1
        next
    }
    /# END WordPress/ { in_wp=0 }
    !in_wp || !wp_done { print }
    ' "$SOURCE_FILE" > "$OUTPUT_FILE"
  # ============================================================================
  # Library: Core Functions (lib-core.sh)
  # ============================================================================
  # Contains: wp(), run(), handle_error(), retry_command(), validate_package_name(), assert()
  # Used by: init.sh
  lib-core.sh: |
    #!/bin/bash
    # WordPress Helm Chart - Core Library
    # Provides essential utility functions for the init script

    # ============================================================================
    # Test Mode Support
    # ============================================================================
    # When TEST_MODE=true, enables assert() for validation
    # Usage: TEST_MODE=true ./init.sh

    # Assert function for testing - validates conditions
    # Only active when TEST_MODE=true
    #
    # Args:
    #   $1 - Description of assertion
    #   $2 - Condition to evaluate (must return 0 for success)
    #
    # Example:
    #   assert "wp command exists" "command -v wp"
    #   assert "plugins directory exists" "[ -d wp-content/plugins ]"
    assert() {
      local description="$1"
      shift
      local condition="$@"

      if [ "${TEST_MODE}" != "true" ]; then
        return 0
      fi

      if eval "$condition"; then
        echo "✓ PASS: $description"
        return 0
      else
        echo "✗ FAIL: $description"
        echo "  Condition: $condition"
        ASSERT_FAILURES=$((${ASSERT_FAILURES:-0} + 1))
        return 1
      fi
    }

    # Print test summary - call at end of script when TEST_MODE=true
    test_summary() {
      if [ "${TEST_MODE}" != "true" ]; then
        return 0
      fi

      echo ""
      echo "========================================="
      echo "Test Summary"
      echo "========================================="
      if [ "${ASSERT_FAILURES:-0}" -eq 0 ]; then
        echo "All assertions passed!"
        return 0
      else
        echo "FAILED: ${ASSERT_FAILURES} assertion(s) failed"
        return 1
      fi
    }

    # ============================================================================
    # DRY_RUN Mode Support
    # ============================================================================
    # When DRY_RUN=true, commands are printed but not executed
    # Useful for testing what would happen without making changes

    # Execute a command, respecting DRY_RUN mode
    # In DRY_RUN mode, prints the command instead of executing
    #
    # Args:
    #   $@ - Command and arguments to execute
    execute() {
      if [ "${DRY_RUN}" = "true" ]; then
        echo "[DRY_RUN] Would execute: $*"
        return 0
      fi
      "$@"
    }

    # ============================================================================
    # Core Helper Functions
    # ============================================================================

    # WP-CLI wrapper with optional debug output
    # Uses global DEBUG flag to control verbosity
    #
    # Args: All arguments are passed through to wp-cli
    #
    # Performance Note:
    #   Each wp call loads WordPress core - can be slow
    #   Use batch operations where possible (e.g., install multiple plugins at once)
    wp() {
      if [ "${DRY_RUN}" = "true" ]; then
        echo "[DRY_RUN] wp $*"
        return 0
      fi
      if [ "${DEBUG}" = "true" ]; then
        command wp --path="${WORDPRESS_PATH}" --debug "$@"
      else
        command wp --path="${WORDPRESS_PATH}" "$@"
      fi
    }

    # Run commands with optional output suppression based on DEBUG flag
    #
    # Args: Command and arguments to execute
    run() {
      if [ "${DRY_RUN}" = "true" ]; then
        echo "[DRY_RUN] $*"
        return 0
      fi
      if [ "${DEBUG}" = "true" ]; then
        "$@"
      else
        "$@" >/dev/null 2>&1
      fi
    }

    # Standardized error handler
    # Logs error message and exits with code 1
    #
    # Args:
    #   $1 - Error message to display
    handle_error() {
      echo "ERROR: $1" >&2
      exit 1
    }

    # Warning handler for non-fatal errors
    # Logs warning but allows script to continue
    #
    # Args:
    #   $1 - Warning message to display
    warn_and_continue() {
      echo "WARNING: $1" >&2
      return 0
    }

    # Retry wrapper for network operations with exponential backoff
    # Retries failed commands up to MAX_RETRIES times with increasing delays
    #
    # Args:
    #   $@ - Command and arguments to execute
    #
    # Returns:
    #   0 - Command succeeded (possibly after retries)
    #   1 - Command failed after all retries exhausted
    retry_command() {
      local max_retries=${MAX_RETRIES:-3}
      local retry_delay=${RETRY_DELAY:-2}
      local attempt=1
      local exit_code=0

      while [ $attempt -le $max_retries ]; do
        if "$@"; then
          return 0
        fi
        exit_code=$?

        if [ $attempt -lt $max_retries ]; then
          local wait_time=$((retry_delay * attempt))
          echo "Command failed (attempt $attempt/$max_retries), retrying in ${wait_time}s..." >&2
          sleep $wait_time
        fi

        attempt=$((attempt + 1))
      done

      echo "Command failed after $max_retries attempts" >&2
      return $exit_code
    }

    # Validate package name to prevent injection attacks
    # Checks for dangerous characters and patterns
    #
    # Args:
    #   $1 - Package name to validate
    #
    # Returns:
    #   0 - Package name is valid
    #   1 - Package name contains invalid characters
    validate_package_name() {
      local name="$1"

      # Check for empty name
      if [ -z "$name" ]; then
        echo "ERROR: Package name cannot be empty" >&2
        return 1
      fi

      # Check for dangerous characters (backticks, semicolons, pipes, etc.)
      if echo "$name" | grep -qE '[`;|&$()<>]'; then
        echo "ERROR: Package name contains invalid characters: $name" >&2
        return 1
      fi

      # Check for path traversal attempts
      if echo "$name" | grep -q '\.\.'; then
        echo "ERROR: Package name contains path traversal: $name" >&2
        return 1
      fi

      return 0
    }
  # ============================================================================
  # Library: Database Lock Functions (lib-lock.sh)
  # ============================================================================
  # Contains: claim_lock_db(), release_lock()
  # Provides distributed locking using WordPress options table
  lib-lock.sh: |
    #!/bin/bash
    # WordPress Helm Chart - Database Lock Library
    # Provides distributed locking for multi-pod deployments

    # Attempt to claim distributed database lock for initialization
    # Ensures only one pod performs WordPress configuration at a time
    #
    # Returns:
    #   0 - Lock successfully claimed or taken over from stale lock
    #   1 - Lock held by another active pod
    #
    # Implementation:
    #   - Uses ATOMIC INSERT...ON DUPLICATE KEY UPDATE for race-condition safety
    #   - wp_options table with option_name='_helm_init_lock'
    #   - Lock value format: "POD_ID-TIMESTAMP"
    #   - Detects stale locks (older than STALE_LOCK_THRESHOLD seconds)
    claim_lock_db() {
      CURRENT_TIME=$(date +%s)
      POD_ID="$$-$(hostname)"

      [ "${DEBUG}" = "true" ] && echo "DEBUG: Using table prefix: $TABLE_PREFIX" >&2
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Attempting to claim lock with POD_ID=$POD_ID-$CURRENT_TIME" >&2

      # Check if wp_options table exists - if not, it's a fresh install
      if ! wp db query "SHOW TABLES LIKE '${TABLE_PREFIX}options';" --skip-column-names 2>/dev/null | grep -q "${TABLE_PREFIX}options"; then
        [ "${DEBUG}" = "true" ] && echo "DEBUG: wp_options table doesn't exist yet, claiming lock for fresh install" >&2
        return 0
      fi

      # Atomic lock claim using INSERT...ON DUPLICATE KEY UPDATE
      wp db query "
        INSERT INTO ${TABLE_PREFIX}options (option_name, option_value, autoload)
        VALUES ('_helm_init_lock', '$POD_ID-$CURRENT_TIME', 'no')
        ON DUPLICATE KEY UPDATE
          option_value = IF(
            CAST(SUBSTRING_INDEX(option_value, '-', -1) AS UNSIGNED) < $CURRENT_TIME - $STALE_LOCK_THRESHOLD,
            '$POD_ID-$CURRENT_TIME',
            option_value
          );
      " >/dev/null 2>&1

      # Small delay to ensure database sync
      sleep 0.1

      # Check if we got the lock
      LOCK_OWNER=$(wp db query "SELECT option_value FROM ${TABLE_PREFIX}options WHERE option_name='_helm_init_lock';" --skip-column-names 2>/dev/null || echo "")
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Current lock owner after atomic claim: $LOCK_OWNER" >&2

      if [[ "$LOCK_OWNER" == "$POD_ID-$CURRENT_TIME" ]]; then
        [ "${DEBUG}" = "true" ] && echo "DEBUG: Successfully claimed lock atomically!" >&2
        return 0
      fi

      # Check lock age for informational purposes
      LOCK_TIME=$(echo "$LOCK_OWNER" | awk -F'-' '{print $NF}')
      if [[ "$LOCK_TIME" =~ ^[0-9]+$ ]]; then
        LOCK_AGE=$((CURRENT_TIME - LOCK_TIME))
        [ "${DEBUG}" = "true" ] && echo "DEBUG: Lock held by another pod, age: ${LOCK_AGE}s" >&2
      fi

      return 1
    }

    # Release database lock by deleting the lock row
    # Called automatically via trap on script exit
    # Safe to call even if lock doesn't exist (|| true)
    # IMPORTANT: Must return 0 to not affect script exit code
    release_lock() {
      wp db query "DELETE FROM ${TABLE_PREFIX:-wp_}options WHERE option_name='_helm_init_lock';" >/dev/null 2>&1 || true
      return 0
    }
  # ============================================================================
  # Library: Composer Functions (lib-composer.sh)
  # ============================================================================
  # Contains: ensure_composer(), composer_exec()
  # Handles Composer installation and package management
  lib-composer.sh: |
    #!/bin/bash
    # WordPress Helm Chart - Composer Library
    # Provides Composer package management utilities

    # Install Composer on-demand to temporary directory
    # Downloads, verifies checksum, and installs to COMPOSER_INSTALL_DIR
    # Idempotent - skips if composer already available
    #
    # Performance Notes:
    #   - Downloads only happen once per pod lifetime
    #   - Uses retry logic for network resilience
    #   - Checksum verification prevents corrupted downloads
    ensure_composer() {
      # Set Composer home to writable directory
      export COMPOSER_HOME="${COMPOSER_HOME_DIR}"
      mkdir -p "$COMPOSER_HOME"

      if ! command -v composer &> /dev/null; then
        echo "Composer not found, installing..."
        cd "${COMPOSER_INSTALL_DIR}" || handle_error "Cannot access Composer install directory"

        # Download Composer installer with retry logic
        echo "  Downloading Composer installer..."
        if ! retry_command php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"; then
          handle_error "Failed to download Composer installer after retries"
        fi

        # Download and verify checksum with retry logic
        echo "  Verifying checksum..."
        if ! EXPECTED_CHECKSUM="$(retry_command php -r 'copy("https://composer.github.io/installer.sig", "php://stdout");')"; then
          rm -f composer-setup.php
          handle_error "Failed to download Composer checksum after retries"
        fi

        ACTUAL_CHECKSUM="$(php -r "echo hash_file('sha384', 'composer-setup.php');")"

        if [ "$EXPECTED_CHECKSUM" != "$ACTUAL_CHECKSUM" ]; then
          rm composer-setup.php
          handle_error "Invalid Composer installer checksum"
        fi

        # Install Composer to temporary location
        echo "  Running installer..."
        php composer-setup.php --quiet --install-dir="${COMPOSER_INSTALL_DIR}" --filename=composer 2>&1 | grep -v "PHP version" | grep -v "diagnose" || true
        rm composer-setup.php

        # Add to PATH for this session
        export PATH="${COMPOSER_INSTALL_DIR}:$PATH"

        echo "  Composer installed!"
      fi
    }

    # Execute composer command with proper environment
    # Wraps composer with DRY_RUN support
    #
    # Args:
    #   $@ - Composer command and arguments
    composer_exec() {
      if [ "${DRY_RUN}" = "true" ]; then
        echo "[DRY_RUN] composer $*"
        return 0
      fi
      composer "$@"
    }
  init.sh: |
    #!/bin/bash
    set -e

    # ============================================================================
    # WordPress Helm Chart Init Script
    # ============================================================================
    #
    # Purpose:
    #   Initializes WordPress installation with plugins, themes, and configuration.
    #   Ensures safe multi-pod deployment using distributed database locking.
    #
    # Features:
    #   - Modular library architecture for maintainability
    #   - Atomic database lock prevents concurrent initialization
    #   - Composer package management for plugins/themes
    #   - Automatic dependency installation and autoloading
    #   - Network retry logic with exponential backoff
    #   - Input validation and injection protection
    #   - Performance optimizations (caching, batch operations)
    #   - DRY_RUN mode for testing without changes
    #   - TEST_MODE with assertions for validation
    #
    # Libraries:
    #   - lib-core.sh: Core utilities (wp, run, handle_error, retry_command, assert)
    #   - lib-lock.sh: Database locking (claim_lock_db, release_lock)
    #   - lib-composer.sh: Composer management (ensure_composer, composer_exec)
    #
    # Environment Variables:
    #   WP_INIT - Enable/disable WordPress core installation
    #   WP_URL - WordPress site URL
    #   WP_TITLE - Site title
    #   WP_ADMIN_USER - Admin username
    #   WP_ADMIN_PASSWORD - Admin password
    #   WP_ADMIN_EMAIL - Admin email
    #   WP_LOCALE - WordPress language locale
    #   DEBUG - Enable verbose debug output (true/false)
    #   DRY_RUN - Print commands without executing (true/false)
    #   TEST_MODE - Enable assertions for testing (true/false)
    #   MAX_RETRIES - Network operation retry count (default: 3)
    #   RETRY_DELAY - Base retry delay in seconds (default: 2)
    #
    # Exit Codes:
    #   0 - Successful initialization
    #   1 - Fatal error (database, lock timeout, invalid input, network failure)
    #
    # ============================================================================

    echo "Starting init script..."

    # ============================================================================
    # Load Libraries
    # ============================================================================
    # Libraries are copied to /tmp/lib by the base init container

    LIB_DIR="/tmp/lib"

    # Source libraries with error handling
    for lib in lib-core.sh lib-lock.sh lib-composer.sh; do
      if [ -f "$LIB_DIR/$lib" ]; then
        # shellcheck source=/dev/null
        source "$LIB_DIR/$lib"
        [ "${DEBUG}" = "true" ] && echo "DEBUG: Loaded library: $lib" >&2
      else
        echo "ERROR: Required library not found: $LIB_DIR/$lib" >&2
        echo "Make sure the base init container has prepared the libraries." >&2
        exit 1
      fi
    done

    # ============================================================================
    # Configuration Constants
    # ============================================================================

    # Database lock configuration
    readonly CHECK_INTERVAL=5
    readonly STALE_LOCK_THRESHOLD=120  # Consider lock stale after 2 minutes (handles pod deletion)
    readonly MAX_WAIT=$((STALE_LOCK_THRESHOLD + 30))  # Wait a bit longer than stale threshold
    readonly DB_CHECK_RETRY_INTERVAL=15  # Seconds between database connection checks

    # WordPress paths
    readonly WP_PLUGINS_DIR="wp-content/plugins"
    readonly WP_THEMES_DIR="wp-content/themes"
    readonly WP_MU_PLUGINS_DIR="wp-content/mu-plugins"

    # Composer configuration
    readonly COMPOSER_HOME_DIR="/tmp/.composer"
    readonly COMPOSER_INSTALL_DIR="/tmp"

    # Runtime variables
    WAIT_TIME=0
    COMPOSER_PACKAGES_MODIFIED=false
    COMPOSER_PLUGINS_PENDING_ACTIVATION=()
    ASSERT_FAILURES=0

    # Setup exit trap for lock release
    trap release_lock EXIT

    # ============================================================================
    # Wait for Database
    # ============================================================================

    echo "Waiting for database..."
    until run wp db check; do
      echo "Database not ready yet, waiting ${DB_CHECK_RETRY_INTERVAL} seconds..."
      sleep "${DB_CHECK_RETRY_INTERVAL}"
    done

    # Cache table prefix once (performance optimization)
    # Avoids repeated wp db prefix calls throughout the script
    TABLE_PREFIX=$(wp db prefix 2>/dev/null || echo "wp_")
    export TABLE_PREFIX
    echo "Using WordPress table prefix: ${TABLE_PREFIX}"

    # ============================================================================
    # WordPress Installation (First-Time Only)
    # ============================================================================

    echo "========================================="
    echo "Setting up WordPress..."
    echo "========================================="

    if [ "${WP_INIT}" = "true" ]; then
      if ! run wp core is-installed --url="${WP_URL}"; then
        run wp core install \
          --url="${WP_URL}" \
          --title="${WP_TITLE}" \
          --admin_user="${WP_ADMIN_USER}" \
          --admin_password="${WP_ADMIN_PASSWORD}" \
          --admin_email="${WP_ADMIN_EMAIL}" \
          --skip-email \
          --locale="${WP_LOCALE}"
      else
        echo "WordPress is already installed, skipping installation."
      fi
    else
      # WP_INIT is false - check if WordPress is already installed
      # Use cached TABLE_PREFIX (set at script start)

      # Check if wp_options table exists
      if ! wp db query "SHOW TABLES LIKE '${TABLE_PREFIX}options';" --skip-column-names 2>/dev/null | grep -q "${TABLE_PREFIX}options"; then
        echo "========================================="
        echo "ERROR: WordPress database tables not found!"
        echo "========================================="
        echo ""
        echo "The database exists but WordPress tables are missing."
        echo "This indicates one of the following issues:"
        echo ""
        echo "1. WordPress initialization has not been performed yet"
        echo "   -> Set wordpress.init.enabled=true in your values.yaml"
        echo ""
        echo "2. Wrong table prefix configured"
        echo "   -> Current prefix: ${TABLE_PREFIX}"
        echo "   -> Check wordpress.tablePrefix in your values.yaml"
        echo ""
        echo "3. Database was reset but persistent volume still exists"
        echo "   -> Delete the PVC and reinstall"
        echo ""
        echo "========================================="
        exit 1
      fi

      echo "WordPress tables found, continuing with configuration..."
    fi

    # ============================================================================
    # Acquire Database Lock
    # Ensures only one pod performs initialization at a time
    # ============================================================================

    echo "Acquiring database lock for initialization..."
    while ! claim_lock_db; do
      if [ $WAIT_TIME -ge $MAX_WAIT ]; then
        echo "Timeout waiting for database lock after ${MAX_WAIT}s"

        # Final attempt to forcefully claim the lock
        POD_ID="$$-$(hostname)"
        CURRENT_TIME=$(date +%s)
        # Use cached TABLE_PREFIX (set at script start)
        wp db query "UPDATE ${TABLE_PREFIX}options SET option_value='$POD_ID-$CURRENT_TIME' WHERE option_name='_helm_init_lock';" >/dev/null 2>&1 || \
        wp db query "INSERT INTO ${TABLE_PREFIX}options (option_name, option_value, autoload) VALUES ('_helm_init_lock', '$POD_ID-$CURRENT_TIME', 'no');" >/dev/null 2>&1

        # Verify we actually got it
        sleep 1
        LOCK_OWNER=$(wp db query "SELECT option_value FROM ${TABLE_PREFIX}options WHERE option_name='_helm_init_lock';" --skip-column-names 2>/dev/null || echo "")
        if [[ "$LOCK_OWNER" == "$POD_ID-$CURRENT_TIME" ]]; then
          echo "Successfully claimed lock after timeout"
          break
        else
          echo "Failed to claim lock - another pod won. Exiting to avoid conflicts."
          exit 1
        fi
      fi

      echo "Another pod is currently running init process, waiting... (${WAIT_TIME}s/${MAX_WAIT}s)"
      sleep $CHECK_INTERVAL
      WAIT_TIME=$((WAIT_TIME + CHECK_INTERVAL))
    done

    echo "Database lock acquired, proceeding with initialization..."

    # ============================================================================
    # Disable WordPress Core Auto-Updates (managed by Helm chart via image updates)
    # ============================================================================

    # Read current auto-update settings in one query
    AUTO_UPDATE_SETTINGS=$(wp db query "SELECT option_name, option_value FROM ${TABLE_PREFIX:-wp_}options WHERE option_name IN ('auto_update_core_dev', 'auto_update_core_minor', 'auto_update_core_major');" --skip-column-names 2>/dev/null || echo "")

    # Check and update each setting only if not already disabled
    for setting in auto_update_core_dev auto_update_core_minor auto_update_core_major; do
      current_value=$(echo "$AUTO_UPDATE_SETTINGS" | grep "^$setting" | awk '{print $2}')
      if [ "$current_value" != "disabled" ]; then
        echo "Disabling $setting..."
        run wp option update "$setting" disabled
      fi
    done

    # ============================================================================
    # WordPress Configuration (Localization, Permalinks, User Metadata)
    # ============================================================================

    if [ "${WP_INIT}" = "true" ]; then
      # Set language
      if [ -n "${WP_LOCALE}" ]; then
        LANG_STATUS=$(wp language core list --language=${WP_LOCALE} --field=status 2>/dev/null || echo "uninstalled")
        case $LANG_STATUS in
          "uninstalled")
            echo "Installing language pack: ${WP_LOCALE}..."
            wp language core install ${WP_LOCALE} --activate
            ;;
          "installed")
            wp site switch-language ${WP_LOCALE}
            ;;
        esac

        # Check if language pack update is available
        LANG_UPDATE=$(wp language core list --language=${WP_LOCALE} --field=update 2>/dev/null || echo "none")
        if [ "$LANG_UPDATE" = "available" ]; then
          echo "Updating language pack for ${WP_LOCALE}..."
          wp language core update || true
        fi
      fi

      # Set permalinks
      if [ -n "${WP_PERMALINK_STRUCTURE}" ]; then
        echo "Setting WordPress permalinks to: ${WP_PERMALINK_STRUCTURE}"
        run wp rewrite structure "${WP_PERMALINK_STRUCTURE}"
        run wp rewrite flush
      fi

      # Set admin user metadata
      if [ -n "${WP_ADMIN_FIRSTNAME}" ]; then
        CURRENT_FIRSTNAME=$(wp user meta get "$WP_ADMIN_USER" first_name 2>/dev/null || echo "")
        if [ "$CURRENT_FIRSTNAME" != "$WP_ADMIN_FIRSTNAME" ]; then
          echo "Setting admin first name..."
          wp user meta update "$WP_ADMIN_USER" first_name "$WP_ADMIN_FIRSTNAME"
        fi
      fi
      if [ -n "${WP_ADMIN_LASTNAME}" ]; then
        CURRENT_LASTNAME=$(wp user meta get "$WP_ADMIN_USER" last_name 2>/dev/null || echo "")
        if [ "$CURRENT_LASTNAME" != "$WP_ADMIN_LASTNAME" ]; then
          echo "Setting admin last name..."
          wp user meta update "$WP_ADMIN_USER" last_name "$WP_ADMIN_LASTNAME"
        fi
      fi
    fi

    # ============================================================================
    # Create Custom Users
    # ============================================================================

    {{- if .Values.wordpress.users }}
    echo "Creating custom users..."
    EXISTING_USERS=$(wp user list --field=user_login 2>/dev/null || echo "")

    {{- range .Values.wordpress.users }}
    if ! echo "$EXISTING_USERS" | grep -q "^{{ .username }}$"; then
      echo "Creating user {{ .username }}..."
      run wp user create "{{ .username }}" "{{ .email }}" \
        --role="{{ .role }}" \
        --display_name="{{ .displayname }}" \
        --first_name="{{ .firstname }}" \
        --last_name="{{ .lastname }}" \
        --send-email="{{ .sendEmail }}"
    else
      echo "User {{ .username }} already exists, skipping."
    fi
    {{- end }}
    {{- else }}
    echo "No custom users specified."
    {{- end }}

    # ============================================================================
    # Composer Configuration
    # ============================================================================

    # Only initialize Composer if we have Composer packages to install
    {{- if or .Values.wordpress.plugins .Values.wordpress.themes }}
    HAS_COMPOSER_PACKAGES=false
    {{- if .Values.wordpress.plugins }}
    {{- range .Values.wordpress.plugins }}
    {{- $name := .name }}
    {{- if and (contains "/" $name) (not (hasPrefix "http://" $name)) (not (hasPrefix "https://" $name)) }}
    HAS_COMPOSER_PACKAGES=true
    {{- end }}
    {{- end }}
    {{- end }}
    {{- if .Values.wordpress.themes }}
    {{- range .Values.wordpress.themes }}
    {{- $name := .name }}
    {{- if and (contains "/" $name) (not (hasPrefix "http://" $name)) (not (hasPrefix "https://" $name)) }}
    HAS_COMPOSER_PACKAGES=true
    {{- end }}
    {{- end }}
    {{- end }}

    if [ "$HAS_COMPOSER_PACKAGES" = "true" ]; then
      echo "========================================="
      echo "Setting up Composer configuration..."
      echo "========================================="
      ensure_composer
      cd /var/www/html || handle_error "Failed to change to /var/www/html directory"

      # Track if any Composer packages were installed/updated (to run composer install later)
      COMPOSER_PACKAGES_MODIFIED=false

      # Initialize composer.json if it doesn't exist
      if [ ! -f composer.json ]; then
        echo "Creating composer.json..."
        cat > composer.json << 'COMPOSERJSON'
    {
      "name": "wordpress/site",
      "description": "WordPress site managed by Helm",
      "type": "project",
      "require": {},
      "repositories": [
        {
          "type": "composer",
          "url": "https://wpackagist.org"
        }{{- if .Values.wordpress.composer.repositories }}{{- range .Values.wordpress.composer.repositories }},
        {
          "type": "{{ .type }}",
          "url": "{{ .url }}"{{- if .options }},
          "options": {{ .options | toJson }}{{- end }}
        }{{- end }}{{- end }}
      ],
      "extra": {
        "installer-paths": {
          "wp-content/plugins/{$name}/": ["type:wordpress-plugin"],
          "wp-content/themes/{$name}/": ["type:wordpress-theme"]
        }
      },
      "config": {
        "allow-plugins": {
          "composer/installers": true
        }
      }
    }
    COMPOSERJSON
        echo "composer.json created!"
      else
        [ "${DEBUG}" = "true" ] && echo "DEBUG: composer.json already exists"
        {{- if .Values.wordpress.composer }}
        # Update repositories in existing composer.json
        [ "${DEBUG}" = "true" ] && echo "DEBUG: Updating custom repositories..."

        # Build JSON array of custom repositories
        CUSTOM_REPOS='[{{- range $index, $repo := .Values.wordpress.composer.repositories }}{{- if $index }},{{- end }}{{ $repo | toJson }}{{- end }}]'

        # Use PHP to merge repositories (wpackagist + custom repos)
        export CUSTOM_REPOS
        TEMP_JSON=$(cat composer.json | php -r '
          $json = json_decode(file_get_contents("php://stdin"), true);
          $customReposJson = getenv("CUSTOM_REPOS");
          $customRepos = json_decode($customReposJson, true);

          // Remove any numeric keys that might have been added by mistake (only at top level)
          $cleanJson = [];
          foreach ($json as $key => $value) {
            if (!is_numeric($key)) {
              $cleanJson[$key] = $value;
            }
          }
          $json = $cleanJson;

          // Keep wpackagist repo
          $wpackagist = ["type" => "composer", "url" => "https://wpackagist.org"];

          // Build repositories array (wpackagist + custom repos)
          $repos = [$wpackagist];
          if (is_array($customRepos) && !empty($customRepos)) {
            foreach ($customRepos as $repo) {
              if (is_array($repo)) {
                $repos[] = $repo;
              }
            }
          }
          $json["repositories"] = $repos;

          // Ensure allow-plugins config is preserved/set
          if (!isset($json["config"])) {
            $json["config"] = [];
          }
          if (!isset($json["config"]["allow-plugins"])) {
            $json["config"]["allow-plugins"] = [];
          }
          $json["config"]["allow-plugins"]["composer/installers"] = true;

          echo json_encode($json, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
        ')

        echo "$TEMP_JSON" > composer.json
        [ "${DEBUG}" = "true" ] && echo "DEBUG: Custom repositories updated!"
        {{- end }}
      fi

      # Set allow-plugins config before requiring composer/installers
      composer config --no-plugins allow-plugins.composer/installers true

      # Ensure composer/installers is available for installer-paths
      if ! composer show composer/installers &>/dev/null; then
        echo "Installing composer/installers..."
        composer require composer/installers --no-interaction --quiet 2>&1 | grep -v "suggest" | grep -v "funding" || true
      fi
    fi
    {{- end }}

    # ============================================================================
    # Plugin Management
    # ============================================================================
    #
    # Process Overview:
    #   1. Cache plugin lists upfront (avoid repeated wp-cli calls)
    #   2. Detect package type (Composer vs WP repository vs URL)
    #   3. Validate package names for security
    #   4. Batch operations for performance
    #   5. Install with retry logic for network resilience
    #   6. Activate and configure auto-updates
    #
    # Performance Optimizations:
    #   - Batch installation (wp plugin install plugin1 plugin2 plugin3)
    #   - Cached plugin lists (single wp-cli call)
    #   - Skip already installed packages
    #
    # Error Handling:
    #   - Validation errors: Skip package with warning
    #   - Network errors: Retry with exponential backoff
    #   - Composer errors: Exit with detailed message

    # Cache all plugin data upfront for performance
    echo "Caching plugin data..."
    INSTALLED_PLUGINS=$(wp plugin list --field=name 2>/dev/null || echo "")
    ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
    AUTOUPDATE_ENABLED=$(wp plugin list --fields=name,auto_update --format=csv 2>/dev/null | grep ",on$" | cut -d',' -f1 || echo "")

    # Detect if a name is a Composer package (vendor/package format)
    #
    # Args:
    #   $1 - Package name to check
    #
    # Returns:
    #   0 - Is a Composer package (contains / but not URL)
    #   1 - Not a Composer package
    #
    # Performance:
    #   String pattern matching (fast, no subprocess)
    #
    # Examples:
    #   is_composer_package "wpackagist-plugin/akismet" -> 0 (true)
    #   is_composer_package "akismet" -> 1 (false)
    #   is_composer_package "https://example.com/plugin.zip" -> 1 (false)
    is_composer_package() {
      local name="$1"
      # Check if it contains / and doesn't start with http:// or https://
      if [[ "$name" == */* ]] && [[ "$name" != http://* ]] && [[ "$name" != https://* ]]; then
        return 0
      fi
      return 1
    }

    # Extract WordPress slug from Composer package name
    # Example: wpackagist-plugin/akismet -> akismet
    #
    # Args:
    #   $1 - Composer package name (vendor/package)
    #
    # Returns:
    #   Package portion after the slash
    get_composer_slug() {
      local package="$1"
      # Extract part after the /
      echo "${package##*/}"
    }

    # Handle metrics plugin
    if [ -n "${WORDPRESS_METRICS}" ]; then
      if echo "$INSTALLED_PLUGINS" | grep -q "^${WORDPRESS_METRICS}$"; then
        if ! echo "$ACTIVE_PLUGINS" | grep -q "^${WORDPRESS_METRICS}$"; then
          wp plugin activate ${WORDPRESS_METRICS} 2>/dev/null || true
          ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
        fi
      else
        echo "Installing WordPress metrics plugin..."
        wp plugin install ${WORDPRESS_METRICS} --activate --force
        INSTALLED_PLUGINS=$(wp plugin list --field=name 2>/dev/null || echo "")
        ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
      fi

      echo "Flushing rewrite rules for metrics plugin..."
      run wp rewrite flush

      if ! echo "$AUTOUPDATE_ENABLED" | grep -q "^${WORDPRESS_METRICS}$"; then
        run wp plugin auto-updates enable ${WORDPRESS_METRICS}
        AUTOUPDATE_ENABLED=$(wp plugin list --fields=name,auto_update --format=csv 2>/dev/null | grep ",on$" | cut -d',' -f1 || echo "")
      fi
    else
      # Remove plugin if WORDPRESS_METRICS is empty and plugin exists
      if [ -n "${WORDPRESS_METRICS}" ] && [ -n "$INSTALLED_PLUGINS" ] && echo "$INSTALLED_PLUGINS" | grep -q "^${WORDPRESS_METRICS}$"; then
        echo "Removing metrics plugin..."
        wp plugin delete ${WORDPRESS_METRICS}
        INSTALLED_PLUGINS=$(wp plugin list --field=name 2>/dev/null || echo "")
      fi
    fi

    # ============================================================================
    # Plugin Management
    # ============================================================================
    #
    # Process Overview:
    #   1. Detect package type (Composer vs WP repository vs URL)
    #   2. Validate package names for security
    #   3. Batch operations for performance
    #   4. Install with retry logic for network resilience
    #   5. Activate and configure auto-updates
    #
    # Performance Optimizations:
    #   - Batch installation (wp plugin install plugin1 plugin2 plugin3)
    #   - Cached plugin lists (avoid repeated wp-cli calls)
    #   - Skip already installed packages
    #
    # Error Handling:
    #   - Validation errors: Skip package with warning
    #   - Network errors: Retry with exponential backoff
    #   - Composer errors: Exit with detailed message
    #
    # Handle custom plugins
    {{- if .Values.wordpress.plugins }}
    echo "========================================="
    echo "Processing plugins..."
    echo "========================================="

    PLUGINS_TO_INSTALL=()
    PLUGINS_TO_ACTIVATE=()
    PLUGINS_TO_AUTOUPDATE=()

    COMPOSER_PLUGINS_TO_INSTALL=()
    COMPOSER_PLUGINS_TO_ACTIVATE=()
    COMPOSER_PLUGINS_TO_UPDATE=()

    {{- range .Values.wordpress.plugins }}
    # Plugin: {{ .name | lower }}
    PLUGIN_NAME="{{ .name | lower }}"

    # Validate package name before processing
    if ! validate_package_name "$PLUGIN_NAME"; then
      echo "Skipping invalid plugin name: $PLUGIN_NAME"
      continue
    fi

    # Check if it's a Composer package
    if is_composer_package "$PLUGIN_NAME"; then
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Detected Composer package: $PLUGIN_NAME"
      COMPOSER_SLUG=$(get_composer_slug "$PLUGIN_NAME")

      # Check if already installed via composer.json AND plugin directory exists
      # Plugin might be in composer.json but files deleted (e.g., after pruning)
      if [ -f /var/www/html/composer.json ] && grep -q "\"$PLUGIN_NAME\"" /var/www/html/composer.json 2>/dev/null; then
        if [ -d "/var/www/html/${WP_PLUGINS_DIR}/${COMPOSER_SLUG}" ]; then
          [ "${DEBUG}" = "true" ] && echo "DEBUG: Composer package $PLUGIN_NAME already installed"

          {{- if .autoupdate }}
          {{- if not .version }}
          # Auto-update only works for packages without fixed version AND already installed
          COMPOSER_PLUGINS_TO_UPDATE+=("$PLUGIN_NAME")
          {{- else }}
          echo "Note: Auto-update skipped for $PLUGIN_NAME (fixed version specified)"
          {{- end }}
          {{- end }}
        else
          # Package in composer.json but files missing - need to run composer install
          echo "Composer package $PLUGIN_NAME in composer.json but plugin directory missing - will reinstall"
          COMPOSER_PACKAGES_MODIFIED=true
        fi
      else
        {{- if .version }}
        COMPOSER_PLUGINS_TO_INSTALL+=("{{ .name | lower }}:{{ .version }}")
        {{- else }}
        COMPOSER_PLUGINS_TO_INSTALL+=("$PLUGIN_NAME")
        {{- end }}
      fi

      {{- if .activate }}
      COMPOSER_PLUGINS_TO_ACTIVATE+=("$COMPOSER_SLUG")
      {{- end }}
    # Check if it's a URL (at runtime, not template time)
    elif [[ "$PLUGIN_NAME" == http://* ]] || [[ "$PLUGIN_NAME" == https://* ]]; then
      echo "Installing URL plugin: $PLUGIN_NAME"
      {{- if .activate }}
      run wp plugin install "$PLUGIN_NAME" --activate --force
      {{- else }}
      run wp plugin install "$PLUGIN_NAME" --force
      {{- end }}
      # Note: Auto-updates for URL plugins are skipped (slug cannot be reliably determined)
    else
      # Named plugin - add to batch processing
      if ! echo "$INSTALLED_PLUGINS" | grep -q "^${PLUGIN_NAME}$"; then
        {{- if .version }}
        PLUGINS_TO_INSTALL+=("{{ .name | lower }}:{{ .version }}")
        {{- else }}
        PLUGINS_TO_INSTALL+=("{{ .name | lower }}")
        {{- end }}
      fi
      {{- if .activate }}
      PLUGINS_TO_ACTIVATE+=("{{ .name | lower }}")
      {{- end }}
      {{- if .autoupdate }}
      PLUGINS_TO_AUTOUPDATE+=("{{ .name | lower }}")
      {{- end }}
    fi
    {{- end }}

    # Batch install plugins
    if [ ${#PLUGINS_TO_INSTALL[@]} -gt 0 ]; then
      echo "Installing ${#PLUGINS_TO_INSTALL[@]} plugin(s)..."

      PLUGINS_NO_VERSION=()
      PLUGINS_WITH_VERSION=()

      for plugin_spec in "${PLUGINS_TO_INSTALL[@]}"; do
        if [[ "$plugin_spec" == *":"* ]]; then
          PLUGINS_WITH_VERSION+=("$plugin_spec")
        else
          PLUGINS_NO_VERSION+=("$plugin_spec")
        fi
      done

      if [ ${#PLUGINS_NO_VERSION[@]} -gt 0 ]; then
        retry_command wp plugin install "${PLUGINS_NO_VERSION[@]}" --force || echo "Warning: Some plugins failed to install"
      fi

      for plugin_spec in "${PLUGINS_WITH_VERSION[@]}"; do
        PLUGIN_NAME="${plugin_spec%%:*}"
        PLUGIN_VERSION="${plugin_spec##*:}"
        retry_command wp plugin install "${PLUGIN_NAME}" --version="${PLUGIN_VERSION}" --force || echo "Warning: Failed to install plugin: ${PLUGIN_NAME}"
      done

      INSTALLED_PLUGINS=$(wp plugin list --field=name 2>/dev/null || echo "")
      ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
    fi

    # Install Composer plugins
    if [ ${#COMPOSER_PLUGINS_TO_INSTALL[@]} -gt 0 ]; then
      echo "Installing ${#COMPOSER_PLUGINS_TO_INSTALL[@]} Composer plugin(s)..."
      cd /var/www/html || handle_error "Failed to change to /var/www/html directory"

      for package_spec in "${COMPOSER_PLUGINS_TO_INSTALL[@]}"; do
        echo "Installing Composer package: $package_spec"
        # Capture output and only show on error, with retry logic
        if ! COMPOSER_OUTPUT=$(retry_command composer require "$package_spec" --no-interaction 2>&1); then
          echo "$COMPOSER_OUTPUT"
          handle_error "Error installing Composer package: $package_spec (failed after retries)"
        fi
      done

      echo "Composer plugins installed!"
      COMPOSER_PACKAGES_MODIFIED=true
      INSTALLED_PLUGINS=$(wp plugin list --field=name 2>/dev/null || echo "")
      ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
    fi

    # Update Composer plugins (auto-update for packages without fixed version)
    if [ ${#COMPOSER_PLUGINS_TO_UPDATE[@]} -gt 0 ]; then
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Checking for Composer plugin updates..."
      cd /var/www/html || handle_error "Failed to change to /var/www/html directory"

      # Get list of outdated packages once (performance optimization)
      OUTDATED_PACKAGES=$(composer outdated --direct --format=json 2>/dev/null | php -r '
        $json = json_decode(file_get_contents("php://stdin"), true);
        if (isset($json["installed"])) {
          foreach ($json["installed"] as $pkg) {
            echo $pkg["name"] . "\n";
          }
        }
      ' 2>/dev/null || echo "")

      PLUGINS_UPDATED=0
      for package in "${COMPOSER_PLUGINS_TO_UPDATE[@]}"; do
        # Check if package has an available update
        if echo "$OUTDATED_PACKAGES" | grep -q "^${package}$"; then
          echo "Updating Composer package: $package"
          # Capture output and only show on error, with retry logic
          if ! COMPOSER_OUTPUT=$(retry_command composer update "$package" --no-interaction 2>&1); then
            echo "$COMPOSER_OUTPUT"
            handle_error "Error updating Composer package: $package (failed after retries)"
          fi
          PLUGINS_UPDATED=$((PLUGINS_UPDATED + 1))
        else
          [ "${DEBUG}" = "true" ] && echo "DEBUG: Package $package is already up to date" >&2
        fi
      done

      if [ $PLUGINS_UPDATED -gt 0 ]; then
        echo "$PLUGINS_UPDATED Composer plugin(s) updated!"
        COMPOSER_PACKAGES_MODIFIED=true
      fi
    fi

    # Install Composer dependencies for plugins NOW (before theme installation)
    # This ensures plugins like s3-uploads have their dependencies (e.g., AWS SDK)
    # available before WordPress loads them during theme installation
    if [ "$COMPOSER_PACKAGES_MODIFIED" = "true" ] || [ ${#COMPOSER_PLUGINS_TO_INSTALL[@]} -gt 0 ]; then
      echo ""
      echo "========================================="
      echo "Installing plugin Composer dependencies..."
      echo "========================================="
      cd /var/www/html || handle_error "Failed to change to /var/www/html directory"

      # Run composer install for main project first
      if ! COMPOSER_OUTPUT=$(retry_command composer install --no-interaction 2>&1 | grep -v "suggest" | grep -v "funding"); then
        echo "$COMPOSER_OUTPUT"
        handle_error "Error installing Composer dependencies (failed after retries)"
      fi

      # Build list of Composer-installed plugin slugs
      COMPOSER_PLUGIN_SLUGS=""
      if [ -f composer.json ]; then
        COMPOSER_PLUGIN_SLUGS=$(php -r '
          $json = json_decode(file_get_contents("composer.json"), true);
          if (isset($json["require"])) {
            foreach ($json["require"] as $package => $version) {
              if (strpos($package, "/") !== false && $package !== "composer/installers") {
                $slug = substr($package, strrpos($package, "/") + 1);
                echo $slug . "\n";
              }
            }
          }
        ' 2>/dev/null || echo "")
      fi

      # Install dependencies for each Composer-installed plugin
      for plugin_dir in ${WP_PLUGINS_DIR}/*/; do
        if [ -f "${plugin_dir}composer.json" ]; then
          PLUGIN_NAME=$(basename "$plugin_dir")

          if echo "$COMPOSER_PLUGIN_SLUGS" | grep -q "^${PLUGIN_NAME}$"; then
            echo "Running composer install in plugin: $PLUGIN_NAME"
            cd "$plugin_dir" || continue
            if composer install --no-dev --no-interaction --ignore-platform-reqs --quiet 2>&1 | grep -E "Error|Warning|Failed" > /tmp/composer-error.txt; then
              cat /tmp/composer-error.txt
              echo "Warning: Could not install dependencies for plugin: $PLUGIN_NAME"
            else
              echo "Successfully installed dependencies for plugin: $PLUGIN_NAME"
            fi
            cd /var/www/html || handle_error "Cannot return to WordPress root directory"
          fi
        fi
      done

      # Create MU-Plugin for Composer autoloader support early
      echo "Creating MU-Plugin for Composer autoloader support..."
      mkdir -p "${WP_MU_PLUGINS_DIR}"
      cat > "${WP_MU_PLUGINS_DIR}/composer-autoloader.php" << 'MUEOF'
    <?php
    /**
     * Plugin Name: Composer Autoloader
     * Description: Automatically loads Composer autoloaders from plugins and themes
     * Author: Helm Chart
     * Version: 1.0.0
     */

    // Load Composer autoloaders from all plugins
    foreach ( glob( WP_CONTENT_DIR . '/plugins/*/vendor/autoload.php' ) as $autoloader ) {
    	require_once $autoloader;
    }

    // Load Composer autoloaders from all themes
    foreach ( glob( WP_CONTENT_DIR . '/themes/*/vendor/autoload.php' ) as $autoloader ) {
    	require_once $autoloader;
    }
    MUEOF
      echo "Composer autoloader MU-Plugin created!"
      echo "Plugin dependencies installed!"
    fi

    # Batch activate plugins
    if [ ${#PLUGINS_TO_ACTIVATE[@]} -gt 0 ]; then
      PLUGINS_NEED_ACTIVATION=()
      for plugin in "${PLUGINS_TO_ACTIVATE[@]}"; do
        if ! echo "$ACTIVE_PLUGINS" | grep -q "^${plugin}$"; then
          PLUGINS_NEED_ACTIVATION+=("$plugin")
        fi
      done

      if [ ${#PLUGINS_NEED_ACTIVATION[@]} -gt 0 ]; then
        echo "Activating ${#PLUGINS_NEED_ACTIVATION[@]} plugin(s)..."
        wp plugin activate "${PLUGINS_NEED_ACTIVATION[@]}" 2>/dev/null || echo "Warning: Some plugins could not be activated"
        ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
      fi
    fi

    # Activate Composer plugins
    # NOTE: This may fail if composer install hasn't run yet - will be retried after composer install
    if [ ${#COMPOSER_PLUGINS_TO_ACTIVATE[@]} -gt 0 ]; then
      COMPOSER_PLUGINS_NEED_ACTIVATION=()
      for plugin in "${COMPOSER_PLUGINS_TO_ACTIVATE[@]}"; do
        if ! echo "$ACTIVE_PLUGINS" | grep -q "^${plugin}$"; then
          COMPOSER_PLUGINS_NEED_ACTIVATION+=("$plugin")
        fi
      done

      if [ ${#COMPOSER_PLUGINS_NEED_ACTIVATION[@]} -gt 0 ]; then
        echo "Activating ${#COMPOSER_PLUGINS_NEED_ACTIVATION[@]} Composer plugin(s)..."
        # Don't fail here - plugins may not exist yet if composer install hasn't run
        # They will be activated after composer install runs
        if ! run wp plugin activate "${COMPOSER_PLUGINS_NEED_ACTIVATION[@]}"; then
          echo "Note: Some Composer plugins couldn't be activated yet - will retry after composer install"
          COMPOSER_PLUGINS_PENDING_ACTIVATION=("${COMPOSER_PLUGINS_NEED_ACTIVATION[@]}")
        else
          ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
        fi
      fi
    fi

    # Batch enable auto-updates
    if [ ${#PLUGINS_TO_AUTOUPDATE[@]} -gt 0 ]; then
      PLUGINS_NEED_AUTOUPDATE=()
      for plugin in "${PLUGINS_TO_AUTOUPDATE[@]}"; do
        if ! echo "$AUTOUPDATE_ENABLED" | grep -q "^${plugin}$"; then
          PLUGINS_NEED_AUTOUPDATE+=("$plugin")
        fi
      done

      if [ ${#PLUGINS_NEED_AUTOUPDATE[@]} -gt 0 ]; then
        echo "Enabling auto-updates for ${#PLUGINS_NEED_AUTOUPDATE[@]} plugin(s)..."
        run wp plugin auto-updates enable "${PLUGINS_NEED_AUTOUPDATE[@]}"
      fi
    fi
    {{- end }}

    {{- if .Values.wordpress.pluginsPrune }}
    # ============================================================================
    # Plugin Pruning - Remove plugins not in the defined list
    # ============================================================================

    # Build comma-separated list of plugins to exclude from deletion
    # Includes both regular plugins and slugs extracted from Composer packages
    EXCLUDE_PLUGINS=""
    COMPOSER_PACKAGES_TO_KEEP=()
    COMPOSER_THEME_PACKAGES_TO_KEEP=()
    {{- $excludeList := list }}
    {{- if .Values.wordpress.plugins }}
    {{- range $plugin := .Values.wordpress.plugins }}
    {{- $name := $plugin.name | lower }}
    {{- if and (contains "/" $name) (not (hasPrefix "http://" $name)) (not (hasPrefix "https://" $name)) }}
    # Composer package: {{ $name }} -> slug: {{ $name | splitList "/" | last }}
    COMPOSER_PACKAGES_TO_KEEP+=("{{ $name }}")
    {{- $excludeList = append $excludeList ($name | splitList "/" | last) }}
    {{- else }}
    # Regular plugin: {{ $name }}
    {{- $excludeList = append $excludeList $name }}
    {{- end }}
    {{- end }}
    {{- end }}
    {{- if $excludeList }}
    EXCLUDE_PLUGINS="{{ $excludeList | join "," }}"
    {{- end }}
    {{- if .Values.wordpress.themes }}
    {{- range .Values.wordpress.themes }}
    {{- $name := .name | lower }}
    {{- if and (contains "/" $name) (not (hasPrefix "http://" $name)) (not (hasPrefix "https://" $name)) }}
    # Composer theme package: {{ $name }}
    COMPOSER_THEME_PACKAGES_TO_KEEP+=("{{ $name }}")
    {{- end }}
    {{- end }}
    {{- end }}
    {{- if .Values.metrics.wordpress.enabled }}
    {{- if .Values.metrics.wordpress.installPlugin }}
    {{- if .Values.metrics.wordpress.pluginNameOverride }}
    [ -n "$EXCLUDE_PLUGINS" ] && EXCLUDE_PLUGINS="${EXCLUDE_PLUGINS},{{ .Values.metrics.wordpress.pluginNameOverride }}" || EXCLUDE_PLUGINS="{{ .Values.metrics.wordpress.pluginNameOverride }}"
    {{- else }}
    [ -n "$EXCLUDE_PLUGINS" ] && EXCLUDE_PLUGINS="${EXCLUDE_PLUGINS},slymetrics" || EXCLUDE_PLUGINS="slymetrics"
    {{- end }}
    {{- end }}
    {{- end }}

    # Delete all plugins except those in the exclude list
    # Only show output if plugins are actually deleted
    if [ -n "$EXCLUDE_PLUGINS" ]; then
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Keeping plugins: $EXCLUDE_PLUGINS"
      PLUGINS_BEFORE=$(wp plugin list --field=name 2>/dev/null | wc -l || echo "0")
      wp plugin delete --all --exclude="$EXCLUDE_PLUGINS" >/dev/null 2>&1 || true
      PLUGINS_AFTER=$(wp plugin list --field=name 2>/dev/null | wc -l || echo "0")
      PRUNED_COUNT=$((PLUGINS_BEFORE - PLUGINS_AFTER))
      if [ "$PRUNED_COUNT" -gt 0 ]; then
        echo "Pruned $PRUNED_COUNT plugin(s)"
      fi
    else
      PLUGINS_COUNT=$(wp plugin list --field=name 2>/dev/null | wc -l || echo "0")
      if [ "$PLUGINS_COUNT" -gt 0 ]; then
        echo "Pruning all $PLUGINS_COUNT plugin(s)..."
        wp plugin delete --all >/dev/null 2>&1 || true
      fi
    fi
    {{- end }}

    # ============================================================================
    # Theme Management
    # ============================================================================
    #
    # Process Overview:
    #   1. Detect package type (Composer vs WP repository vs URL)
    #   2. Validate package names for security
    #   3. Batch operations for performance
    #   4. Install with retry logic for network resilience
    #   5. Activate theme and configure auto-updates
    #
    # Performance Optimizations:
    #   - Batch installation (wp theme install theme1 theme2 theme3)
    #   - Cached theme lists (avoid repeated wp-cli calls)
    #   - Skip already installed packages
    #
    # Error Handling:
    #   - Validation errors: Skip package with warning
    #   - Network errors: Retry with exponential backoff
    #   - Composer errors: Exit with detailed message
    #
    echo "========================================="
    echo "Processing themes..."
    echo "========================================="

    # Cache all theme data upfront
    INSTALLED_THEMES=$(wp theme list --field=name 2>/dev/null || echo "")
    ACTIVE_THEME=$(wp theme list --status=active --field=name 2>/dev/null || echo "")
    AUTOUPDATE_ENABLED_THEMES=$(wp theme list --fields=name,auto_update --format=csv 2>/dev/null | grep ",on$" | cut -d',' -f1 || echo "")

    # Extract theme slug from theme name or URL
    # Handles both direct theme names and .zip URLs
    #
    # Args:
    #   $1 - Theme name or URL (e.g., "astra" or "https://example.com/theme.zip")
    #
    # Returns:
    #   Theme slug (filename without .zip extension for URLs)
    #
    # Examples:
    #   get_theme_slug "astra" -> "astra"
    #   get_theme_slug "https://example.com/mytheme.zip" -> "mytheme"
    get_theme_slug() {
      local theme_name="$1"
      if [[ "$theme_name" == *".zip" ]]; then
        basename "$theme_name" .zip
      else
        echo "$theme_name"
      fi
    }

    THEMES_TO_INSTALL=()
    THEME_TO_ACTIVATE=""
    THEMES_TO_AUTOUPDATE=()

    COMPOSER_THEMES_TO_INSTALL=()
    COMPOSER_THEME_TO_ACTIVATE=""
    COMPOSER_THEMES_TO_UPDATE=()

    {{- range .Values.wordpress.themes }}
    THEME_NAME="{{ .name | lower }}"

    # Validate package name before processing
    if ! validate_package_name "$THEME_NAME"; then
      echo "Skipping invalid theme name: $THEME_NAME"
      continue
    fi

    # Check if it's a Composer package
    if is_composer_package "$THEME_NAME"; then
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Detected Composer theme package: $THEME_NAME"
      COMPOSER_THEME_SLUG=$(get_composer_slug "$THEME_NAME")

      # Check if already installed via composer.json AND theme directory exists
      # Theme might be in composer.json but files deleted (e.g., after pruning)
      if [ -f /var/www/html/composer.json ] && grep -q "\"$THEME_NAME\"" /var/www/html/composer.json 2>/dev/null; then
        if [ -d "/var/www/html/${WP_THEMES_DIR}/${COMPOSER_THEME_SLUG}" ]; then
          [ "${DEBUG}" = "true" ] && echo "DEBUG: Composer theme package $THEME_NAME already installed"

          {{- if .autoupdate }}
          {{- if not .version }}
          # Auto-update only works for packages without fixed version AND already installed
          COMPOSER_THEMES_TO_UPDATE+=("$THEME_NAME")
          {{- else }}
          echo "Note: Auto-update skipped for theme $THEME_NAME (fixed version specified)"
          {{- end }}
          {{- end }}
        else
          # Package in composer.json but files missing - need to run composer install
          echo "Composer theme package $THEME_NAME in composer.json but theme directory missing - will reinstall"
          COMPOSER_PACKAGES_MODIFIED=true
        fi
      else
        {{- if .version }}
        COMPOSER_THEMES_TO_INSTALL+=("{{ .name | lower }}:{{ .version }}")
        {{- else }}
        COMPOSER_THEMES_TO_INSTALL+=("$THEME_NAME")
        {{- end }}
      fi

      {{- if .activate }}
      COMPOSER_THEME_TO_ACTIVATE="$COMPOSER_THEME_SLUG"
      {{- end }}
    else
      THEME_SLUG=$(get_theme_slug "{{ .name | lower }}")

      if ! echo "$INSTALLED_THEMES" | grep -q "^${THEME_SLUG}$"; then
        {{- if .version }}
        THEMES_TO_INSTALL+=("{{ .name | lower }}:{{ .version }}")
        {{- else }}
        THEMES_TO_INSTALL+=("{{ .name | lower }}")
        {{- end }}
      fi
      {{- if .activate }}
      THEME_TO_ACTIVATE="${THEME_SLUG}"
      {{- end }}
      {{- if .autoupdate }}
      THEMES_TO_AUTOUPDATE+=("${THEME_SLUG}")
      {{- end }}
    fi
    {{- end }}

    # Batch install themes
    if [ ${#THEMES_TO_INSTALL[@]} -gt 0 ]; then
      echo "Installing ${#THEMES_TO_INSTALL[@]} theme(s)..."

      THEMES_SIMPLE=()
      THEMES_URLS=()
      THEMES_WITH_VERSION=()

      for theme_spec in "${THEMES_TO_INSTALL[@]}"; do
        if [[ "$theme_spec" == http://* ]] || [[ "$theme_spec" == https://* ]]; then
          THEMES_URLS+=("$theme_spec")
        elif [[ "$theme_spec" == *":"* ]]; then
          THEMES_WITH_VERSION+=("$theme_spec")
        else
          THEMES_SIMPLE+=("$theme_spec")
        fi
      done

      if [ ${#THEMES_SIMPLE[@]} -gt 0 ]; then
        retry_command wp theme install "${THEMES_SIMPLE[@]}" --force || echo "Warning: Some themes failed to install"
      fi

      for theme_url in "${THEMES_URLS[@]}"; do
        echo "Installing theme from URL: $theme_url"
        retry_command wp theme install "$theme_url" --force || echo "Warning: Failed to install theme from URL: $theme_url"
      done

      for theme_spec in "${THEMES_WITH_VERSION[@]}"; do
        THEME_NAME="${theme_spec%%:*}"
        THEME_VERSION="${theme_spec##*:}"
        echo "Installing theme ${THEME_NAME} version ${THEME_VERSION}..."
        retry_command wp theme install "${THEME_NAME}" --version="${THEME_VERSION}" --force || echo "Warning: Failed to install theme: ${THEME_NAME}"
      done

      INSTALLED_THEMES=$(wp theme list --field=name 2>/dev/null || echo "")
      ACTIVE_THEME=$(wp theme list --status=active --field=name 2>/dev/null || echo "")
    fi

    # Install Composer themes
    if [ ${#COMPOSER_THEMES_TO_INSTALL[@]} -gt 0 ]; then
      echo "Installing ${#COMPOSER_THEMES_TO_INSTALL[@]} Composer theme(s)..."
      cd /var/www/html || handle_error "Failed to change to /var/www/html directory"

      for package_spec in "${COMPOSER_THEMES_TO_INSTALL[@]}"; do
        echo "Installing Composer theme package: $package_spec"
        # Capture output and only show on error, with retry logic
        if ! COMPOSER_OUTPUT=$(retry_command composer require "$package_spec" --no-interaction 2>&1); then
          echo "$COMPOSER_OUTPUT"
          handle_error "Error installing Composer theme package: $package_spec (failed after retries)"
        fi
      done

      echo "Composer themes installed!"
      COMPOSER_PACKAGES_MODIFIED=true
      INSTALLED_THEMES=$(wp theme list --field=name 2>/dev/null || echo "")
      ACTIVE_THEME=$(wp theme list --status=active --field=name 2>/dev/null || echo "")
    fi

    # Update Composer themes (auto-update for packages without fixed version)
    if [ ${#COMPOSER_THEMES_TO_UPDATE[@]} -gt 0 ]; then
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Checking for Composer theme updates..."
      cd /var/www/html || handle_error "Failed to change to /var/www/html directory"

      # Get list of outdated packages once (performance optimization)
      # Re-use existing OUTDATED_PACKAGES if already fetched, otherwise fetch now
      if [ -z "$OUTDATED_PACKAGES" ]; then
        OUTDATED_PACKAGES=$(composer outdated --direct --format=json 2>/dev/null | php -r '
          $json = json_decode(file_get_contents("php://stdin"), true);
          if (isset($json["installed"])) {
            foreach ($json["installed"] as $pkg) {
              echo $pkg["name"] . "\n";
            }
          }
        ' 2>/dev/null || echo "")
      fi

      THEMES_UPDATED=0
      for package in "${COMPOSER_THEMES_TO_UPDATE[@]}"; do
        # Check if package has an available update
        if echo "$OUTDATED_PACKAGES" | grep -q "^${package}$"; then
          echo "Updating Composer theme package: $package"
          # Capture output and only show on error, with retry logic
          if ! COMPOSER_OUTPUT=$(retry_command composer update "$package" --no-interaction 2>&1); then
            echo "$COMPOSER_OUTPUT"
            handle_error "Error updating Composer theme package: $package (failed after retries)"
          fi
          THEMES_UPDATED=$((THEMES_UPDATED + 1))
        else
          [ "${DEBUG}" = "true" ] && echo "DEBUG: Theme package $package is already up to date" >&2
        fi
      done

      if [ $THEMES_UPDATED -gt 0 ]; then
        echo "$THEMES_UPDATED Composer theme(s) updated!"
        COMPOSER_PACKAGES_MODIFIED=true
      fi
    fi

    # Activate theme
    if [ -n "$THEME_TO_ACTIVATE" ] && [ "$ACTIVE_THEME" != "$THEME_TO_ACTIVATE" ]; then
      echo "Activating theme: $THEME_TO_ACTIVATE"
      run wp theme activate "$THEME_TO_ACTIVATE"
    fi

    # Activate Composer theme
    if [ -n "$COMPOSER_THEME_TO_ACTIVATE" ] && [ "$ACTIVE_THEME" != "$COMPOSER_THEME_TO_ACTIVATE" ]; then
      echo "Activating Composer theme: $COMPOSER_THEME_TO_ACTIVATE"
      run wp theme activate "$COMPOSER_THEME_TO_ACTIVATE"
    fi

    # Batch enable auto-updates
    if [ ${#THEMES_TO_AUTOUPDATE[@]} -gt 0 ]; then
      THEMES_NEED_AUTOUPDATE=()
      for theme in "${THEMES_TO_AUTOUPDATE[@]}"; do
        if ! echo "$AUTOUPDATE_ENABLED_THEMES" | grep -q "^${theme}$"; then
          THEMES_NEED_AUTOUPDATE+=("$theme")
        fi
      done

      if [ ${#THEMES_NEED_AUTOUPDATE[@]} -gt 0 ]; then
        echo "Enabling auto-updates for ${#THEMES_NEED_AUTOUPDATE[@]} theme(s)..."
        run wp theme auto-updates enable "${THEMES_NEED_AUTOUPDATE[@]}"
      fi
    fi

    {{- if .Values.wordpress.themesPrune }}
    # ============================================================================
    # Theme Pruning - Remove themes not in the defined list
    # ============================================================================

    # Build list of theme slugs to keep
    THEMES_TO_KEEP=()
    {{- if .Values.wordpress.themes }}
    {{- range .Values.wordpress.themes }}
    {{- $name := .name | lower }}
    {{- if and (contains "/" $name) (not (hasPrefix "http://" $name)) (not (hasPrefix "https://" $name)) }}
    # Composer theme package: {{ $name }}
    # Extract theme slug from Composer package name (e.g., wpackagist-theme/astra -> astra)
    THEME_SLUG=$(echo "{{ $name }}" | sed 's/.*\///')
    THEMES_TO_KEEP+=("$THEME_SLUG")
    {{- else }}
    # Regular theme: {{ $name }}
    THEME_SLUG=$(get_theme_slug "{{ $name }}")
    THEMES_TO_KEEP+=("$THEME_SLUG")
    {{- end }}
    {{- end }}
    {{- end }}

    # Get all installed themes and active theme
    INSTALLED_THEMES=$(wp theme list --field=name 2>/dev/null || echo "")
    ACTIVE_THEME=$(wp theme list --status=active --field=name 2>/dev/null || echo "")

    # Check if active theme should be pruned (will be handled before deletion)
    ACTIVE_THEME_SHOULD_BE_PRUNED=false
    if [ -n "$ACTIVE_THEME" ]; then
      ACTIVE_IN_KEEP_LIST=false
      for keep_theme in "${THEMES_TO_KEEP[@]}"; do
        if [ "$ACTIVE_THEME" = "$keep_theme" ]; then
          ACTIVE_IN_KEEP_LIST=true
          break
        fi
      done

      if [ "$ACTIVE_IN_KEEP_LIST" = false ]; then
        ACTIVE_THEME_SHOULD_BE_PRUNED=true

        # Try to activate a theme from the keep list
        FALLBACK_THEME=""
        for keep_theme in "${THEMES_TO_KEEP[@]}"; do
          if echo "$INSTALLED_THEMES" | grep -q "^${keep_theme}$"; then
            FALLBACK_THEME="$keep_theme"
            break
          fi
        done

        if [ -n "$FALLBACK_THEME" ]; then
          echo "Activating fallback theme: $FALLBACK_THEME (current active theme '$ACTIVE_THEME' is not in keep list)"
          if wp theme activate "$FALLBACK_THEME" 2>/dev/null; then
            echo "Successfully activated fallback theme: $FALLBACK_THEME"
            ACTIVE_THEME="$FALLBACK_THEME"
          else
            echo "ERROR: Failed to activate fallback theme. Active theme '$ACTIVE_THEME' will be kept to prevent site breakage." >&2
            ACTIVE_THEME_SHOULD_BE_PRUNED=false
          fi
        else
          echo "ERROR: Active theme '$ACTIVE_THEME' is not in keep list but no alternative theme available. Keeping it to prevent site breakage." >&2
          ACTIVE_THEME_SHOULD_BE_PRUNED=false
        fi
      fi
    fi

    # Build list of themes to delete (installed themes minus keep list minus active theme)
    THEMES_TO_DELETE=()
    for theme in $INSTALLED_THEMES; do
      # Safety: Never delete the active theme (even if it should be pruned but couldn't be switched)
      if [ "$theme" = "$ACTIVE_THEME" ]; then
        continue
      fi

      # Check if theme is in the keep list
      KEEP=false
      for keep_theme in "${THEMES_TO_KEEP[@]}"; do
        if [ "$theme" = "$keep_theme" ]; then
          KEEP=true
          break
        fi
      done

      if [ "$KEEP" = false ]; then
        THEMES_TO_DELETE+=("$theme")
      fi
    done

    # Delete all themes in one command for better performance
    if [ ${#THEMES_TO_DELETE[@]} -gt 0 ]; then
      echo "Pruning ${#THEMES_TO_DELETE[@]} theme(s): ${THEMES_TO_DELETE[*]}"
      wp theme delete "${THEMES_TO_DELETE[@]}" 2>/dev/null || true
    fi

    # Remove Composer packages (plugins & themes) not in the keep lists
    if [ -f /var/www/html/composer.json ]; then
      cd /var/www/html || handle_error "Failed to change to /var/www/html directory"

      # Ensure Composer is available for pruning operations
      ensure_composer

      # Get all currently required packages from composer.json (excluding composer/installers)
      # Use PHP for reliable JSON parsing (performance: single process vs multiple sed/grep calls)
      if [ -f composer.json ]; then
        CURRENT_PACKAGES=$(php -r '
          $json = json_decode(file_get_contents("composer.json"), true);
          if (isset($json["require"])) {
            foreach ($json["require"] as $package => $version) {
              if ($package !== "composer/installers") {
                echo $package . "\n";
              }
            }
          }
        ' 2>/dev/null || echo "")
      else
        CURRENT_PACKAGES=""
      fi

      # Debug: Show what we're keeping
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Composer packages to keep: ${COMPOSER_PACKAGES_TO_KEEP[*]}" >&2
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Composer theme packages to keep: ${COMPOSER_THEME_PACKAGES_TO_KEEP[*]}" >&2
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Current packages in composer.json: $CURRENT_PACKAGES" >&2

      # Get active theme (might be a Composer theme)
      ACTIVE_THEME=$(wp theme list --status=active --field=name 2>/dev/null || echo "")

      # Track packages that should be removed
      PACKAGES_TO_REMOVE=()
      ACTIVE_THEME_PACKAGE=""

      for package in $CURRENT_PACKAGES; do
        KEEP=false

        # Check if it's in the plugin keep list
        for keep_package in "${COMPOSER_PACKAGES_TO_KEEP[@]}"; do
          if [ "$package" = "$keep_package" ]; then
            KEEP=true
            break
          fi
        done

        # If not found in plugins, check theme keep list
        if [ "$KEEP" = false ]; then
          for keep_package in "${COMPOSER_THEME_PACKAGES_TO_KEEP[@]}"; do
            if [ "$package" = "$keep_package" ]; then
              KEEP=true
              break
            fi
          done
        fi

        # Check if this package is the active theme
        if [[ "$package" == wpackagist-theme/* ]]; then
          PACKAGE_SLUG="${package#wpackagist-theme/}"
          if [ "$PACKAGE_SLUG" = "$ACTIVE_THEME" ]; then
            ACTIVE_THEME_PACKAGE="$package"
            if [ "$KEEP" = false ]; then
              echo "WARNING: Active theme '$ACTIVE_THEME' is a Composer package ($package) not in the keep list"
            else
              # Active theme is in keep list, safe to continue
              continue
            fi
          fi
        fi

        if [ "$KEEP" = false ]; then
          PACKAGES_TO_REMOVE+=("$package")
        fi
      done

      # If active theme should be removed, try to activate fallback first
      # Note: This handles Composer theme packages that were already checked during WordPress theme pruning
      if [ -n "$ACTIVE_THEME_PACKAGE" ]; then
        # Only show message if we haven't already handled this theme above
        if [ "$ACTIVE_THEME_SHOULD_BE_PRUNED" = "false" ]; then
          # Theme was already processed above, just skip removal silently
          TEMP_PACKAGES=()
          for pkg in "${PACKAGES_TO_REMOVE[@]}"; do
            if [ "$pkg" != "$ACTIVE_THEME_PACKAGE" ]; then
              TEMP_PACKAGES+=("$pkg")
            fi
          done
          PACKAGES_TO_REMOVE=("${TEMP_PACKAGES[@]}")
        fi
        # If ACTIVE_THEME_SHOULD_BE_PRUNED=true, the theme was already switched above, so we can safely remove it
      fi

      # Remove all packages in one go
      if [ ${#PACKAGES_TO_REMOVE[@]} -gt 0 ]; then
        echo "========================================="
        echo "Pruning Composer packages..."
        echo "========================================="
        echo "Removing ${#PACKAGES_TO_REMOVE[@]} Composer package(s): ${PACKAGES_TO_REMOVE[*]}"
        for package in "${PACKAGES_TO_REMOVE[@]}"; do
          echo "Removing: $package"
          if ! COMPOSER_OUTPUT=$(composer remove "$package" --no-interaction --quiet 2>&1); then
            echo "$COMPOSER_OUTPUT"
            echo "Error removing Composer package: $package"
          fi
        done
        echo "Composer packages pruned successfully!"
      fi
    fi
    {{- end }}

    # Install Composer theme dependencies after theme installation
    # Plugin dependencies were already installed before theme processing
    #
    # This section handles:
    #   - Running composer install for themes with their own composer.json
    #   - Activating Composer plugins that couldn't be activated before
    #
    # Note: Main composer install and plugin dependencies were already done
    # before theme installation to prevent loading errors (e.g., s3-uploads AWS SDK)
    if [ "$COMPOSER_PACKAGES_MODIFIED" = "true" ] || [ ! -d /var/www/html/vendor ]; then
      cd /var/www/html || handle_error "Failed to change to /var/www/html directory"

      # Ensure vendor directory exists (may have been created during plugin dependency install)
      if [ ! -d /var/www/html/vendor ]; then
        echo "Vendor directory missing, running composer install..."
        if ! COMPOSER_OUTPUT=$(retry_command composer install --no-interaction 2>&1 | grep -v "suggest" | grep -v "funding"); then
          echo "$COMPOSER_OUTPUT"
          handle_error "Error installing Composer dependencies (failed after retries)"
        fi
      fi

      # Build list of Composer-installed theme slugs from the require list
      COMPOSER_THEME_SLUGS=""
      if [ -f composer.json ]; then
        COMPOSER_THEME_SLUGS=$(php -r '
          $json = json_decode(file_get_contents("composer.json"), true);
          if (isset($json["require"])) {
            foreach ($json["require"] as $package => $version) {
              // Only process theme packages
              if (strpos($package, "wpackagist-theme/") === 0 ||
                  (strpos($package, "/") !== false && strpos($package, "theme") !== false)) {
                $slug = substr($package, strrpos($package, "/") + 1);
                echo $slug . "\n";
              }
            }
          }
        ' 2>/dev/null || echo "")
      fi

      # Install theme-specific Composer dependencies
      THEMES_WITH_DEPS=0
      for theme_dir in ${WP_THEMES_DIR}/*/; do
        if [ -f "${theme_dir}composer.json" ]; then
          THEME_NAME=$(basename "$theme_dir")

          # Only run composer install if this theme was installed via Composer
          if echo "$COMPOSER_THEME_SLUGS" | grep -q "^${THEME_NAME}$"; then
            [ $THEMES_WITH_DEPS -eq 0 ] && echo "Installing theme-specific Composer dependencies..."
            echo "Running composer install in theme: $THEME_NAME"
            cd "$theme_dir" || continue
            if composer install --no-dev --no-interaction --ignore-platform-reqs --quiet 2>&1 | grep -E "Error|Warning|Failed" > /tmp/composer-error.txt; then
              cat /tmp/composer-error.txt
              echo "Warning: Could not install dependencies for theme: $THEME_NAME"
            else
              echo "Successfully installed dependencies for theme: $THEME_NAME"
            fi
            cd /var/www/html || handle_error "Cannot return to WordPress root directory"
            THEMES_WITH_DEPS=$((THEMES_WITH_DEPS + 1))
          else
            [ "${DEBUG}" = "true" ] && echo "DEBUG: Skipping $THEME_NAME - not a Composer-installed theme" >&2
          fi
        fi
      done

      # Activate Composer plugins that couldn't be activated before (dependencies were missing)
      if [ ${#COMPOSER_PLUGINS_PENDING_ACTIVATION[@]} -gt 0 ]; then
        echo "Activating Composer plugins after dependency installation..."
        ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
        PLUGINS_STILL_NEED_ACTIVATION=()
        for plugin in "${COMPOSER_PLUGINS_PENDING_ACTIVATION[@]}"; do
          if ! echo "$ACTIVE_PLUGINS" | grep -q "^${plugin}$"; then
            PLUGINS_STILL_NEED_ACTIVATION+=("$plugin")
          fi
        done
        if [ ${#PLUGINS_STILL_NEED_ACTIVATION[@]} -gt 0 ]; then
          echo "Activating ${#PLUGINS_STILL_NEED_ACTIVATION[@]} Composer plugin(s)..."
          run wp plugin activate "${PLUGINS_STILL_NEED_ACTIVATION[@]}" || echo "Warning: Some plugins could not be activated"
        fi
      fi
    fi

    # ============================================================================
    # Custom Init Commands
    # ============================================================================
    {{- if .Values.wordpress.init.customInitConfigMap.name }}

    echo "Running custom init commands from ConfigMap..."
    if [ -f /tmp/custom-init-commands/{{ .Values.wordpress.init.customInitConfigMap.key | default "commands.sh" }} ]; then
      # Execute the custom commands script (already executable via defaultMode: 0755)
      /tmp/custom-init-commands/{{ .Values.wordpress.init.customInitConfigMap.key | default "commands.sh" }}
      echo "Custom init commands completed!"
    else
      echo "Warning: Custom commands file not found in ConfigMap"
    fi
    {{- end }}

    # ============================================================================
    # Release Lock and Complete
    # ============================================================================

    # Print test summary if in TEST_MODE
    test_summary

    # Lock will be released automatically via trap on EXIT
    echo "Database lock released."
    echo "Init script completed successfully!"

    # Explicitly exit with success code
    exit 0