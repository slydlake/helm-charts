{{- if or (not .Values.apache.customDefaultSiteConfigMap) (not .Values.apache.customPortsConfigMap) (not .Values.apache.customPhpConfigMap) (not .Values.wordpress.htaccessConfigMap)  }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "wordpress.fullname" . }}-configfiles
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "wordpress.labels" . | nindent 4 }}
data:
  {{- if (not .Values.apache.customDefaultSiteConfigMap)  }}
  000-default.conf: |
    {{- if .Values.apache.customDefaultSiteConfig }}
    {{ .Values.apache.customDefaultSiteConfig | nindent 4 }}
    {{- else if .Values.metrics.apache.enabled }}
    <VirtualHost *:{{ .Values.service.ports.http }}>
            ServerAdmin webmaster@localhost
            <Location "/server-status">
                    SetHandler server-status
                    Require local
            </Location>
            DocumentRoot /var/www/html
            ErrorLog ${APACHE_LOG_DIR}/error.log
            CustomLog ${APACHE_LOG_DIR}/access.log combined
    </VirtualHost>
    {{- else }}
    <VirtualHost *:{{ .Values.service.ports.http }}>
            ServerAdmin webmaster@localhost
            DocumentRoot /var/www/html

            ErrorLog ${APACHE_LOG_DIR}/error.log
            CustomLog ${APACHE_LOG_DIR}/access.log combined
    </VirtualHost>
    {{- end }}
  {{- end }}
  {{- if (not .Values.apache.customPortsConfigMap) }}
  ports.conf: |
    {{- if .Values.apache.customPortsConfig }}
    {{ .Values.apache.customPortsConfig | nindent 4 }}
    {{- else }}
    Listen {{ .Values.service.ports.http }}
    {{- end }}
  {{- end }}
  {{- if (not .Values.apache.customPhpConfigMap) }}
  custom.ini: |
    {{- if and .Values.apache.customPhpConfig  (not .Values.apache.customPhpConfigMap) }}
    {{ .Values.apache.customPhpConfig | nindent 4 }}
    {{- end }}
  {{- end }}
  {{- if (not .Values.wordpress.htaccessConfigMap) }}
  htaccess: |
    {{- if and .Values.wordpress.htaccess  (not .Values.wordpress.htaccessConfigMap) }}
    {{ .Values.wordpress.htaccess | nindent 4 }}
    {{ else if .Values.metrics.apache.enabled }}
    # Server-status exception
    <IfModule mod_rewrite.c>
    RewriteRule ^server-status - [L]
    </IfModule>

    # BEGIN WordPress
    # The directives (lines) between "BEGIN WordPress" and "END WordPress" are
    # dynamically generated and will be automatically injected by the init container.
    # Any changes to the directives between these markers will be overwritten.
    # END WordPress
    {{ else }}
    # BEGIN WordPress
    # The directives (lines) between "BEGIN WordPress" and "END WordPress" are
    # dynamically generated and will be automatically injected by the init container.
    # Any changes to the directives between these markers will be overwritten.
    # END WordPress
    {{- end }}
  {{- end }}
{{- end }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "wordpress.fullname" . }}-init
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "wordpress.labels" . | nindent 4 }}
data:
  base.sh: |
    #!/bin/bash
    # Check if WordPress files exist; if not copy them but exclude wp-content.
    if [ ! -e /tmp/wordpress/index.php ] && [ ! -e /tmp/wordpress/wp-includes/version.php ]; then
        echo "WordPress not found in /tmp/wordpress - copying now..."
        # Use a for loop to copy everything except wp-content
        mkdir -p /tmp/wordpress
        cd /usr/src/wordpress || exit 0
        for item in *; do
          if [ "$item" != "wp-content" ]; then
            cp -r "$item" /tmp/wordpress/ || exit 1
          fi
          # Handle wp-config-docker.php
          if [ "$item" = "wp-config-docker.php" ] && [ ! -s /tmp/wordpress/wp-config.php ]; then
            awk '
              /put your unique phrase here/ {
                cmd = "head -c1m /dev/urandom | sha1sum | cut -d\\  -f1"
                cmd | getline str
                close(cmd)
                gsub("put your unique phrase here", str)
              }
              { print }
            ' "$item" > /tmp/wordpress/wp-config.php
          fi
        done
        
        # Also try to copy any existing wp-content from /var/www/html if present
        if [ ! -d /tmp/wordpress/wp-content ]; then
            cp -r /var/www/html/wp-content /tmp/wordpress/wp-content 2>/dev/null || true
        fi
        echo "Complete! WordPress has been successfully copied to /tmp/wordpress"
    else
        echo "WordPress already present in /tmp/wordpress - skipping copy"
    fi
    echo "Base script completed!"
  htaccess-setup.sh: |
    #!/bin/sh
    # Script to setup .htaccess on persistent volume
    # This runs in the base init container
    
    echo "Starting .htaccess setup..."
    
    # Check if .htaccess already exists on persistent volume
    if [ ! -f /tmp/wordpress/.htaccess ]; then
      echo ".htaccess not found on persistent volume, creating from ConfigMap..."
      
      # Copy and make injection script executable
      cp /tmp/scripts/htaccess-inject.sh /tmp/htaccess-inject.sh
      chmod +x /tmp/htaccess-inject.sh
      
      # Copy .htaccess from ConfigMap and inject WordPress rules
      /tmp/htaccess-inject.sh \
        /tmp/configfiles/.htaccess \
        /tmp/wordpress/.htaccess \
        /tmp/scripts/wordpress-rewrite-rules.txt
      
      # Set correct ownership and permissions
      chown www-data:www-data /tmp/wordpress/.htaccess
      chmod 664 /tmp/wordpress/.htaccess
      echo "WordPress rewrite rules successfully injected and written to persistent volume!"
    else
      echo ".htaccess already exists on persistent volume."
      
      # Check if WordPress block exists but is empty (only comments between markers)
      if grep -q "# BEGIN WordPress" /tmp/wordpress/.htaccess; then
        # Extract content between BEGIN and END WordPress (excluding the markers themselves)
        WP_BLOCK_CONTENT=$(awk '/# BEGIN WordPress/,/# END WordPress/{if (!/# BEGIN WordPress/ && !/# END WordPress/) print}' /tmp/wordpress/.htaccess | grep -v "^#" | grep -v "^[[:space:]]*$")
        
        if [ -z "$WP_BLOCK_CONTENT" ]; then
          echo "WordPress block exists but is empty, injecting default rules..."
          
          # Copy and make injection script executable
          cp /tmp/scripts/htaccess-inject.sh /tmp/htaccess-inject.sh
          chmod +x /tmp/htaccess-inject.sh
          
          # Inject WordPress rewrite rules into existing .htaccess
          /tmp/htaccess-inject.sh \
            /tmp/wordpress/.htaccess \
            /tmp/htaccess-temp \
            /tmp/scripts/wordpress-rewrite-rules.txt
          
          mv /tmp/htaccess-temp /tmp/wordpress/.htaccess
          chown www-data:www-data /tmp/wordpress/.htaccess
          chmod 664 /tmp/wordpress/.htaccess
          echo "WordPress rewrite rules successfully injected into existing .htaccess!"
        else
          echo "WordPress block already has content, preserving existing configuration."
        fi
      else
        echo "No WordPress block found, preserving existing .htaccess as-is."
      fi
    fi
    
    echo ".htaccess setup completed!"
  wordpress-rewrite-rules.txt: |
    <IfModule mod_rewrite.c>
    RewriteEngine On
    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
    RewriteBase /
    RewriteRule ^index\.php$ - [L]
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteRule . /index.php [L]
    </IfModule>
  htaccess-inject.sh: |
    #!/bin/sh
    # Script to inject WordPress rewrite rules into .htaccess
    # Usage: htaccess-inject.sh <source-htaccess> <output-htaccess> <rules-file>
    
    SOURCE_FILE="$1"
    OUTPUT_FILE="$2"
    RULES_FILE="$3"
    
    awk -v rules_file="$RULES_FILE" '
    BEGIN { 
        in_wp=0
        wp_done=0
        # Read rules from file
        while ((getline line < rules_file) > 0) {
            rules = rules line "\n"
        }
        close(rules_file)
    }
    /# BEGIN WordPress/ { 
        print
        printf "%s", rules
        in_wp=1
        wp_done=1
        next
    }
    /# END WordPress/ { in_wp=0 }
    !in_wp || !wp_done { print }
    ' "$SOURCE_FILE" > "$OUTPUT_FILE"
  init.sh: |
    #!/bin/bash
    echo "Starting init script..."
              
    # WP-CLI wrapper: always set path, and append --debug when DEBUG=true
    wp() {
      if [ "${DEBUG}" = "true" ]; then
        command wp --path="${WORDPRESS_PATH}" --debug "$@"
      else
        command wp --path="${WORDPRESS_PATH}" "$@"
      fi
    }

    # Helper to run commands with optional output suppression.
    # If DEBUG is true, run the command verbosely; otherwise suppress stdout+stderr.
    run() {
      if [ "${DEBUG}" = "true" ]; then
        "$@"
      else
        "$@" >/dev/null 2>&1
      fi
    }

    # Wait for database to be ready
    echo "Waiting for database..."
    until run wp db check; do
      echo "Database not ready yet, waiting 15 seconds..."
      sleep 15
    done

    # set up WordPress
    if [ "${WP_INIT}" = "true" ]; then
      # Check if WordPress database is already installed
      if ! run wp core is-installed --url="${WP_URL}"; then
        echo "Setting up WordPress..."
        run wp core install \
          --url="${WP_URL}" \
          --title="${WP_TITLE}" \
          --admin_user="${WP_ADMIN_USER}" \
          --admin_password="${WP_ADMIN_PASSWORD}" \
          --admin_email="${WP_ADMIN_EMAIL}" \
          --skip-email \
          --locale="${WP_LOCALE}"
      else
        echo "WordPress is already installed, skipping installation."
      fi

      # set up localization
      if [ -n "${WP_LOCALE}" ]; then
        # Set language if WordPress is already installed
        LANG_STATUS=$(wp language core list --language=${WP_LOCALE} --field=status)
        case $LANG_STATUS in
          "uninstalled")
            wp language core install ${WP_LOCALE} --activate
            ;;
          "installed")
            wp site switch-language ${WP_LOCALE}
            ;;
        esac
      fi

      # Set Wordpress permalinks
      echo "Setting WordPress permalinks..."
      if [ ! -z "${WP_PERMALINK_STRUCTURE}" ]; then
        wp rewrite structure "${WP_PERMALINK_STRUCTURE}"
        wp rewrite flush
      fi

      # Set user metadata
      echo "Setting user metadata..."
      if [ ! -z "${WP_ADMIN_FIRSTNAME}" ]; then
        wp user meta update "$WP_ADMIN_USER" first_name "$WP_ADMIN_FIRSTNAME"
      fi
      if [ ! -z "${WP_ADMIN_LASTNAME}" ]; then
        wp user meta update "$WP_ADMIN_USER" last_name "$WP_ADMIN_LASTNAME"
      fi
    fi

    # Handle WordPress users if specified
    {{- if .Values.wordpress.users }}
    echo "Creating custom users..."
    
    # Get all existing users once (performance boost!)
    EXISTING_USERS=$(wp user list --field=user_login 2>/dev/null || echo "")
    
    {{- range .Values.wordpress.users }}
    USER_USERNAME="{{ .username }}"
    USER_EMAIL="{{ .email }}"
    USER_DISPLAYNAME="{{ .displayname }}"
    USER_FIRSTNAME="{{ .firstname }}"
    USER_LASTNAME="{{ .lastname }}"
    USER_ROLE="{{ .role }}"
    USER_SENDEMAIL="{{ .sendEmail }}"

    # Check if user already exists (using cached list)
    if ! echo "$EXISTING_USERS" | grep -q "^${USER_USERNAME}$"; then
      echo "Creating user ${USER_USERNAME}..."
      run wp user create "${USER_USERNAME}" "${USER_EMAIL}" \
        --role="${USER_ROLE}" \
        --display_name="${USER_DISPLAYNAME}" \
        --first_name="${USER_FIRSTNAME}" \
        --last_name="${USER_LASTNAME}" \
        --send-email="${USER_SENDEMAIL}"
    else
      echo "User ${USER_USERNAME} already exists, skipping."
    fi
    {{- end }}
    {{- else }}
    echo "No custom users specified."
    {{- end }}




    # Get all installed plugins once at the start (HUGE performance boost!)
    # This prevents 17+ separate wp-cli calls that each take 4-8 seconds
    INSTALLED_PLUGINS=$(wp plugin list --field=name 2>/dev/null || echo "")
    ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
    # Get plugins with auto-update enabled (check update_version field to detect auto-update status)
    AUTOUPDATE_ENABLED=$(wp plugin list --fields=name,auto_update --format=csv 2>/dev/null | grep ",on$" | cut -d',' -f1 || echo "")

    # Handle WordPress metrics plugin if specified
    if [ ! -z "${WORDPRESS_METRICS}" ]; then
      # Check if plugin is installed (using cached list)
      if echo "$INSTALLED_PLUGINS" | grep -q "^${WORDPRESS_METRICS}$"; then
        # Check if active (using cached list)
        if ! echo "$ACTIVE_PLUGINS" | grep -q "^${WORDPRESS_METRICS}$"; then
          run wp plugin activate ${WORDPRESS_METRICS}
          ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
        fi
      else
        echo "Installing WordPress metrics plugin..."
        wp plugin install ${WORDPRESS_METRICS} --activate --force
        # Refresh cached lists after install
        INSTALLED_PLUGINS=$(wp plugin list --field=name 2>/dev/null || echo "")
        ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
      fi

      # Flush rewrite rules to ensure metrics endpoints are registered
      echo "Flushing rewrite rules for metrics plugin..."
      run wp rewrite flush

      # Enable auto-updates if disabled (using cached list)
      if ! echo "$AUTOUPDATE_ENABLED" | grep -q "^${WORDPRESS_METRICS}$"; then
        run wp plugin auto-updates enable ${WORDPRESS_METRICS}
        AUTOUPDATE_ENABLED=$(wp plugin list --fields=name,auto_update --format=csv 2>/dev/null | grep ",on$" | cut -d',' -f1 || echo "")
      fi
    else
      # Remove plugin if WORDPRESS_METRICS is empty
      if echo "$INSTALLED_PLUGINS" | grep -q "^${WORDPRESS_METRICS}$"; then
        wp plugin delete ${WORDPRESS_METRICS}
        INSTALLED_PLUGINS=$(wp plugin list --field=name 2>/dev/null || echo "")
      fi
    fi

    # Handle WordPress plugins if specified
    {{- if .Values.wordpress.plugins }}
    echo "Installing custom plugins..."
    
    # Use cached plugin lists from above (no need to fetch again!)

    
    # Prepare arrays for batch operations
    PLUGINS_TO_INSTALL=()
    PLUGINS_TO_ACTIVATE=()
    PLUGINS_TO_AUTOUPDATE=()
    
    {{- range .Values.wordpress.plugins }}
    PLUGIN_NAME="{{ .name }}"
    PLUGIN_VERSION="{{ .version }}"
    PLUGIN_ACTIVATE="{{ .activate }}"
    PLUGIN_AUTOUPDATE="{{ .autoupdate }}"

    # Check if plugin needs installation (using grep on cached list)
    if ! echo "$INSTALLED_PLUGINS" | grep -q "^${PLUGIN_NAME}$"; then
      if [ -n "${PLUGIN_VERSION}" ]; then
        PLUGINS_TO_INSTALL+=("${PLUGIN_NAME}:${PLUGIN_VERSION}")
      else
        PLUGINS_TO_INSTALL+=("${PLUGIN_NAME}")
      fi
    fi

    # Track plugins to activate
    if [ "${PLUGIN_ACTIVATE}" = "true" ]; then
      PLUGINS_TO_ACTIVATE+=("${PLUGIN_NAME}")
    fi

    # Track plugins for auto-update
    if [ "${PLUGIN_AUTOUPDATE}" = "true" ]; then
      PLUGINS_TO_AUTOUPDATE+=("${PLUGIN_NAME}")
    fi
    {{- end }}

    # Batch install plugins
    if [ ${#PLUGINS_TO_INSTALL[@]} -gt 0 ]; then
      echo "Installing ${#PLUGINS_TO_INSTALL[@]} plugin(s)..."
      
      # Separate plugins with and without versions
      PLUGINS_NO_VERSION=()
      PLUGINS_WITH_VERSION=()
      
      for plugin_spec in "${PLUGINS_TO_INSTALL[@]}"; do
        if [[ "$plugin_spec" == *":"* ]]; then
          PLUGINS_WITH_VERSION+=("$plugin_spec")
        else
          PLUGINS_NO_VERSION+=("$plugin_spec")
        fi
      done
      
      # Install all plugins without version in one batch
      if [ ${#PLUGINS_NO_VERSION[@]} -gt 0 ]; then
        wp plugin install "${PLUGINS_NO_VERSION[@]}" --force
      fi
      
      # Install versioned plugins individually (wp-cli limitation)
      for plugin_spec in "${PLUGINS_WITH_VERSION[@]}"; do
        PLUGIN_NAME="${plugin_spec%%:*}"
        PLUGIN_VERSION="${plugin_spec##*:}"
        wp plugin install "${PLUGIN_NAME}" --version="${PLUGIN_VERSION}" --force
      done
      
      # Refresh plugin lists after installation
      INSTALLED_PLUGINS=$(wp plugin list --field=name 2>/dev/null || echo "")
      ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
    fi

    # Batch activate plugins
    if [ ${#PLUGINS_TO_ACTIVATE[@]} -gt 0 ]; then
      PLUGINS_NEED_ACTIVATION=()
      for plugin in "${PLUGINS_TO_ACTIVATE[@]}"; do
        # Check against cached active plugins list
        if ! echo "$ACTIVE_PLUGINS" | grep -q "^${plugin}$"; then
          PLUGINS_NEED_ACTIVATION+=("$plugin")
        fi
      done
      
      if [ ${#PLUGINS_NEED_ACTIVATION[@]} -gt 0 ]; then
        echo "Activating ${#PLUGINS_NEED_ACTIVATION[@]} plugin(s)..."
        run wp plugin activate "${PLUGINS_NEED_ACTIVATION[@]}"
        # Refresh active plugins list after activation
        ACTIVE_PLUGINS=$(wp plugin list --status=active --field=name 2>/dev/null || echo "")
      fi
    fi

    # Batch enable auto-updates
    if [ ${#PLUGINS_TO_AUTOUPDATE[@]} -gt 0 ]; then
      PLUGINS_NEED_AUTOUPDATE=()
      for plugin in "${PLUGINS_TO_AUTOUPDATE[@]}"; do
        # Check against cached auto-update list
        if ! echo "$AUTOUPDATE_ENABLED" | grep -q "^${plugin}$"; then
          PLUGINS_NEED_AUTOUPDATE+=("$plugin")
        fi
      done
      
      if [ ${#PLUGINS_NEED_AUTOUPDATE[@]} -gt 0 ]; then
        echo "Enabling auto-updates for ${#PLUGINS_NEED_AUTOUPDATE[@]} plugin(s)..."
        run wp plugin auto-updates enable "${PLUGINS_NEED_AUTOUPDATE[@]}"
      fi
    fi
    {{- else }}
    echo "No custom plugins specified."
    {{- end }}

    # Handle WordPress themes if specified
    {{- if .Values.wordpress.themes }}
    echo "Installing custom themes..."
    
    # Get all installed themes once (performance boost!)
    INSTALLED_THEMES=$(wp theme list --field=name 2>/dev/null || echo "")
    ACTIVE_THEME=$(wp theme list --status=active --field=name 2>/dev/null || echo "")
    # Get themes with auto-update enabled (check auto_update field)
    AUTOUPDATE_ENABLED_THEMES=$(wp theme list --fields=name,auto_update --format=csv 2>/dev/null | grep ",on$" | cut -d',' -f1 || echo "")
    
    # Helper function to extract theme slug from name/URL
    get_theme_slug() {
      local theme_name="$1"
      if [[ "$theme_name" == *".zip" ]]; then
        basename "$theme_name" .zip
      else
        echo "$theme_name"
      fi
    }
    
    # Prepare arrays for batch operations
    THEMES_TO_INSTALL=()
    THEME_TO_ACTIVATE=""
    THEMES_TO_AUTOUPDATE=()
    
    {{- range .Values.wordpress.themes }}
    THEME_NAME="{{ .name }}"
    THEME_VERSION="{{ .version }}"
    THEME_ACTIVATE="{{ .activate }}"
    THEME_AUTOUPDATE="{{ .autoupdate }}"
    
    THEME_SLUG=$(get_theme_slug "${THEME_NAME}")

    # Check if theme needs installation (using grep on cached list)
    if ! echo "$INSTALLED_THEMES" | grep -q "^${THEME_SLUG}$"; then
      if [ -n "${THEME_VERSION}" ]; then
        THEMES_TO_INSTALL+=("${THEME_NAME}:${THEME_VERSION}")
      else
        THEMES_TO_INSTALL+=("${THEME_NAME}")
      fi
    fi

    # Only one theme can be active at a time - use last one marked for activation
    if [ "${THEME_ACTIVATE}" = "true" ]; then
      THEME_TO_ACTIVATE="${THEME_SLUG}"
    fi

    # Track themes for auto-update (use slug)
    if [ "${THEME_AUTOUPDATE}" = "true" ]; then
      THEMES_TO_AUTOUPDATE+=("${THEME_SLUG}")
    fi
    {{- end }}

    # Batch install themes
    if [ ${#THEMES_TO_INSTALL[@]} -gt 0 ]; then
      echo "Installing ${#THEMES_TO_INSTALL[@]} theme(s)..."
      
      # Separate themes by type: URLs, versioned, and simple names
      THEMES_SIMPLE=()
      THEMES_URLS=()
      THEMES_WITH_VERSION=()
      
      for theme_spec in "${THEMES_TO_INSTALL[@]}"; do
        if [[ "$theme_spec" == http://* ]] || [[ "$theme_spec" == https://* ]]; then
          # It's a URL - needs individual install
          THEMES_URLS+=("$theme_spec")
        elif [[ "$theme_spec" == *":"* ]]; then
          # Has version specified (not a URL)
          THEMES_WITH_VERSION+=("$theme_spec")
        else
          # Simple theme name - can be batched!
          THEMES_SIMPLE+=("$theme_spec")
        fi
      done
      
      # Batch install all simple themes at once (HUGE speedup!)
      if [ ${#THEMES_SIMPLE[@]} -gt 0 ]; then
        echo "Batch installing ${#THEMES_SIMPLE[@]} theme(s)..."
        wp theme install "${THEMES_SIMPLE[@]}" --force
      fi
      
      # Install URL themes individually (wp-cli limitation)
      for theme_url in "${THEMES_URLS[@]}"; do
        echo "Installing theme from URL: $theme_url"
        wp theme install "$theme_url" --force
      done
      
      # Install versioned themes individually (wp-cli limitation)
      for theme_spec in "${THEMES_WITH_VERSION[@]}"; do
        THEME_NAME="${theme_spec%%:*}"
        THEME_VERSION="${theme_spec##*:}"
        echo "Installing theme ${THEME_NAME} version ${THEME_VERSION}..."
        wp theme install "${THEME_NAME}" --version="${THEME_VERSION}" --force
      done
      
      # Refresh theme lists after installation (only once!)
      INSTALLED_THEMES=$(wp theme list --field=name 2>/dev/null || echo "")
      ACTIVE_THEME=$(wp theme list --status=active --field=name 2>/dev/null || echo "")
    fi

    # Activate theme (only one can be active)
    if [ -n "$THEME_TO_ACTIVATE" ]; then
      # Check against cached active theme
      if [ "$ACTIVE_THEME" != "$THEME_TO_ACTIVATE" ]; then
        echo "Activating theme: $THEME_TO_ACTIVATE"
        run wp theme activate "$THEME_TO_ACTIVATE"
        ACTIVE_THEME="$THEME_TO_ACTIVATE"
      fi
    fi

    # Batch enable auto-updates
    if [ ${#THEMES_TO_AUTOUPDATE[@]} -gt 0 ]; then
      THEMES_NEED_AUTOUPDATE=()
      for theme in "${THEMES_TO_AUTOUPDATE[@]}"; do
        # Check against cached auto-update list
        if ! echo "$AUTOUPDATE_ENABLED_THEMES" | grep -q "^${theme}$"; then
          THEMES_NEED_AUTOUPDATE+=("$theme")
        fi
      done
      
      if [ ${#THEMES_NEED_AUTOUPDATE[@]} -gt 0 ]; then
        echo "Enabling auto-updates for ${#THEMES_NEED_AUTOUPDATE[@]} theme(s)..."
        run wp theme auto-updates enable "${THEMES_NEED_AUTOUPDATE[@]}"
      fi
    fi
    {{- else }}
    echo "No custom themes specified."
    {{- end }}

    echo "Init script completed!"