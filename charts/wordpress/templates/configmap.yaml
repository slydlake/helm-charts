{{- if or (not .Values.apache.customDefaultSiteConfigMap) (not .Values.apache.customPortsConfigMap) (not .Values.apache.customPhpConfigMap) (not .Values.wordpress.htaccessConfigMap)  }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "wordpress.fullname" . }}-configfiles
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "wordpress.labels" . | nindent 4 }}
data:
  {{- if (not .Values.apache.customDefaultSiteConfigMap)  }}
  000-default.conf: |
    {{- if .Values.apache.customDefaultSiteConfig }}
    {{ .Values.apache.customDefaultSiteConfig | nindent 4 }}
    {{- else if .Values.metrics.apache.enabled }}
    <VirtualHost *:{{ .Values.service.ports.http }}>
            ServerAdmin webmaster@localhost
            <Location "/server-status">
                    SetHandler server-status
                    Require local
            </Location>
            DocumentRoot /var/www/html
            ErrorLog ${APACHE_LOG_DIR}/error.log
            CustomLog ${APACHE_LOG_DIR}/access.log combined
    </VirtualHost>
    {{- else }}
    <VirtualHost *:{{ .Values.service.ports.http }}>
            ServerAdmin webmaster@localhost
            DocumentRoot /var/www/html

            ErrorLog ${APACHE_LOG_DIR}/error.log
            CustomLog ${APACHE_LOG_DIR}/access.log combined
    </VirtualHost>
    {{- end }}
  {{- end }}
  {{- if (not .Values.apache.customPortsConfigMap) }}
  ports.conf: |
    {{- if .Values.apache.customPortsConfig }}
    {{ .Values.apache.customPortsConfig | nindent 4 }}
    {{- else }}
    Listen {{ .Values.service.ports.http }}
    {{- end }}
  {{- end }}
  {{- if (not .Values.apache.customPhpConfigMap) }}
  custom.ini: |
    {{- if and .Values.apache.customPhpConfig  (not .Values.apache.customPhpConfigMap) }}
    {{ .Values.apache.customPhpConfig | nindent 4 }}
    {{- end }}
  {{- end }}
  {{- if (not .Values.wordpress.htaccessConfigMap) }}
  htaccess: |
    {{- if and .Values.wordpress.htaccess  (not .Values.wordpress.htaccessConfigMap) }}
    {{ .Values.wordpress.htaccess | nindent 4 }}
    {{ else if .Values.metrics.apache.enabled }}
    # Server-status exception
    <IfModule mod_rewrite.c>
    RewriteRule ^server-status - [L]
    </IfModule>

    # BEGIN WordPress
    # The directives (lines) between "BEGIN WordPress" and "END WordPress" are
    # dynamically generated and will be automatically injected by the init container.
    # Any changes to the directives between these markers will be overwritten.
    # END WordPress
    {{ else }}
    # BEGIN WordPress
    # The directives (lines) between "BEGIN WordPress" and "END WordPress" are
    # dynamically generated and will be automatically injected by the init container.
    # Any changes to the directives between these markers will be overwritten.
    # END WordPress
    {{- end }}
  {{- end }}
{{- end }}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "wordpress.fullname" . }}-init
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "wordpress.labels" . | nindent 4 }}
data:
  base.sh: |
    #!/bin/bash

    # Helper function to extract WordPress version from version.php
    get_wp_version() {
      local version_file="$1"
      if [ -f "$version_file" ]; then
        grep "^\$wp_version" "$version_file" | sed "s/.*'\([^']*\)'.*/\1/"
      else
        echo ""
      fi
    }

    # Helper function to copy WordPress core files (excludes wp-content)
    copy_wp_core() {
      echo "Copying WordPress core files..."
      cd /usr/src/wordpress || exit 1
      for item in *; do
        if [ "$item" != "wp-content" ]; then
          cp -r "$item" /tmp/wordpress/ || exit 1
        fi
      done
      echo "WordPress core files copied successfully!"
    }

    # Get versions from image and PVC
    IMAGE_VERSION=$(get_wp_version "/usr/src/wordpress/wp-includes/version.php")
    PVC_VERSION=$(get_wp_version "/tmp/wordpress/wp-includes/version.php")

    echo "========================================="
    echo "WordPress Version Check"
    echo "========================================="
    echo "Image version: ${IMAGE_VERSION:-'not found'}"
    echo "PVC version:   ${PVC_VERSION:-'not installed'}"
    echo "========================================="

    # Check if WordPress needs to be installed or updated
    if [ -z "$PVC_VERSION" ]; then
        echo "WordPress not found in /tmp/wordpress - fresh installation..."
        mkdir -p /tmp/wordpress
        copy_wp_core

        # Handle wp-config-docker.php for fresh install
        if [ -f "/usr/src/wordpress/wp-config-docker.php" ] && [ ! -f /tmp/wordpress/wp-config.php ]; then
          awk '
            /put your unique phrase here/ {
              cmd = "head -c1m /dev/urandom | sha1sum | cut -d\\  -f1"
              cmd | getline str
              close(cmd)
              gsub("put your unique phrase here", str)
            }
            { print }
          ' /usr/src/wordpress/wp-config-docker.php > /tmp/wordpress/wp-config.php
        fi

        # Copy wp-content skeleton if not present
        if [ ! -d /tmp/wordpress/wp-content ]; then
            cp -r /usr/src/wordpress/wp-content /tmp/wordpress/wp-content 2>/dev/null || true
        fi
        echo "Complete! WordPress has been successfully installed to /tmp/wordpress"

    elif [ "$IMAGE_VERSION" != "$PVC_VERSION" ]; then
        echo "WordPress version mismatch detected!"
        echo "Updating core files from $PVC_VERSION to $IMAGE_VERSION..."
        echo "Note: wp-content directory will be preserved."
        copy_wp_core
        echo "Complete! WordPress core has been updated to $IMAGE_VERSION"

        # Mark that a core update happened (used by init.sh to disable auto-updates)
        touch /tmp/wordpress/.wp-core-updated

    else
        echo "WordPress version matches - no update needed."
    fi


    # ============================================================================
    # Setup MU-Plugins from ConfigMaps
    # ============================================================================
    {{- if .Values.wordpress.muPluginsConfigMaps }}
    echo ""
    echo "Setting up MU-Plugins from ConfigMaps..."
    echo "========================================="


    # Create mu-plugins directory if it doesn't exist
    mkdir -p /tmp/wordpress/wp-content/mu-plugins
    chown www-data:www-data /tmp/wordpress/wp-content/mu-plugins
    chmod 755 /tmp/wordpress/wp-content/mu-plugins


    {{- range .Values.wordpress.muPluginsConfigMaps }}
    # Copy files from ConfigMap: {{ .name }}
    if [ -d "/tmp/mu-plugins-{{ .name }}" ]; then
      {{- if .key }}
      # Copy specific key only
      if [ -f "/tmp/mu-plugins-{{ .name }}/{{ .key }}" ]; then
        echo "Copying MU-Plugin file {{ .key }} from {{ .name }}..."
        cp /tmp/mu-plugins-{{ .name }}/{{ .key }} /tmp/wordpress/wp-content/mu-plugins/
        chown www-data:www-data /tmp/wordpress/wp-content/mu-plugins/{{ .key }}
        chmod 644 /tmp/wordpress/wp-content/mu-plugins/{{ .key }}
        echo "MU-Plugin file {{ .key }} from {{ .name }} copied successfully!"
      else
        echo "Warning: Key {{ .key }} not found in ConfigMap {{ .name }}"
      fi
      {{- else }}
      # Copy all files from ConfigMap
      echo "Copying all MU-Plugin files from {{ .name }}..."
      cp -r -L /tmp/mu-plugins-{{ .name }}/* /tmp/wordpress/wp-content/mu-plugins/ 2>/dev/null || true
      # Set correct ownership and permissions for all copied files
      find /tmp/wordpress/wp-content/mu-plugins -type f -exec chown www-data:www-data {} \;
      find /tmp/wordpress/wp-content/mu-plugins -type f -exec chmod 644 {} \;
      echo "MU-Plugin files from {{ .name }} copied successfully!"
      {{- end }}
    else
      echo "Warning: MU-Plugin ConfigMap mount {{ .name }} not found"
    fi
    {{- end }}


    echo "MU-Plugins setup completed!"
    {{- else }}
    echo "No MU-Plugins ConfigMaps configured."
    {{- end }}


    # ============================================================================
    # Custom Init Commands ConfigMap Info
    # ============================================================================
    {{- if .Values.wordpress.init.customInitConfigMap.name }}
    echo ""
    echo "Custom init commands ConfigMap detected: {{ .Values.wordpress.init.customInitConfigMap.name }}"
    {{- end }}


    echo "========================================="
    echo "Base script completed!"
    echo "========================================="
  htaccess-setup.sh: |
    #!/bin/sh
    # Script to setup .htaccess on persistent volume
    # This runs in the base init container


    echo "Starting .htaccess setup..."


    # Copy and make injection script executable once
    cp /scripts/htaccess-inject.sh /tmp/htaccess-inject.sh
    chmod +x /tmp/htaccess-inject.sh


    # Check if .htaccess already exists on persistent volume
    if [ ! -f /tmp/wordpress/.htaccess ]; then
      echo ".htaccess not found on persistent volume, creating from ConfigMap..."


      # Copy .htaccess from ConfigMap and inject WordPress rules
      /tmp/htaccess-inject.sh \
        /configfiles/.htaccess \
        /tmp/wordpress/.htaccess \
        /scripts/wordpress-rewrite-rules.txt

      # Set correct ownership and permissions
      chown www-data:www-data /tmp/wordpress/.htaccess
      chmod 664 /tmp/wordpress/.htaccess
      echo "WordPress rewrite rules successfully injected and written to persistent volume!"
    else
      echo ".htaccess already exists on persistent volume."


      # Extract WordPress block content from existing file (if it exists)
      if grep -q "# BEGIN WordPress" /tmp/wordpress/.htaccess; then
        echo "Extracting WordPress block content from existing .htaccess..."


        # Extract ONLY the content between markers (excluding the markers themselves)
        awk '/# BEGIN WordPress/,/# END WordPress/{if (!/# BEGIN WordPress/ && !/# END WordPress/) print}' /tmp/wordpress/.htaccess > /tmp/wp-block-content.txt


        # Start with fresh ConfigMap .htaccess and inject the existing WordPress block content
        /tmp/htaccess-inject.sh \
          /configfiles/.htaccess \
          /tmp/htaccess-new \
          /tmp/wp-block-content.txt


        # Replace old .htaccess with updated one
        mv /tmp/htaccess-new /tmp/wordpress/.htaccess
        chown www-data:www-data /tmp/wordpress/.htaccess
        chmod 664 /tmp/wordpress/.htaccess
        echo "ConfigMap .htaccess updated with existing WordPress block content!"
      else
        echo "No WordPress block found in existing .htaccess."


        # Inject default WordPress rules into fresh ConfigMap .htaccess
        /tmp/htaccess-inject.sh \
          /configfiles/.htaccess \
          /tmp/htaccess-new \
          /scripts/wordpress-rewrite-rules.txt

        # Replace old .htaccess with updated one
        mv /tmp/htaccess-new /tmp/wordpress/.htaccess
        chown www-data:www-data /tmp/wordpress/.htaccess
        chmod 664 /tmp/wordpress/.htaccess
        echo "ConfigMap .htaccess applied with default WordPress rules!"
      fi
    fi


    echo "========================================="
    echo ".htaccess setup completed!"
    echo "========================================="
  wordpress-rewrite-rules.txt: |
    <IfModule mod_rewrite.c>
    RewriteEngine On
    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]
    RewriteBase /
    RewriteRule ^index\.php$ - [L]
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteCond %{REQUEST_FILENAME} !-d
    RewriteRule . /index.php [L]
    </IfModule>
  htaccess-inject.sh: |
    #!/bin/sh
    # Script to inject WordPress rewrite rules into .htaccess
    # Usage: htaccess-inject.sh <source-htaccess> <output-htaccess> <rules-file>


    SOURCE_FILE="$1"
    OUTPUT_FILE="$2"
    RULES_FILE="$3"


    awk -v rules_file="$RULES_FILE" '
    BEGIN {
        in_wp=0
        wp_done=0
        # Read rules from file
        while ((getline line < rules_file) > 0) {
            rules = rules line "\n"
        }
        close(rules_file)
    }
    /# BEGIN WordPress/ {
        print
        printf "%s", rules
        in_wp=1
        wp_done=1
        next
    }
    /# END WordPress/ { in_wp=0 }
    !in_wp || !wp_done { print }
    ' "$SOURCE_FILE" > "$OUTPUT_FILE"
  # ============================================================================
  # Library: Core Functions (lib-core.sh)
  # ============================================================================
  # Contains: wp(), run(), handle_error(), retry_command(), validate_package_name(), assert()
  # Used by: init.sh
  lib-core.sh: |
    #!/bin/bash
    # WordPress Helm Chart - Core Library
    # Provides essential utility functions for the init script

    # ============================================================================
    # Test Mode Support
    # ============================================================================
    # When TEST_MODE=true, enables assert() for validation
    # Usage: TEST_MODE=true ./init.sh

    # Assert function for testing - validates conditions
    # Only active when TEST_MODE=true
    #
    # Args:
    #   $1 - Description of assertion
    #   $2 - Condition to evaluate (must return 0 for success)
    #
    # Example:
    #   assert "wp command exists" "command -v wp"
    #   assert "plugins directory exists" "[ -d wp-content/plugins ]"
    assert() {
      local description="$1"
      shift
      local condition="$@"

      if [ "${TEST_MODE}" != "true" ]; then
        return 0
      fi

      if eval "$condition"; then
        echo "✓ PASS: $description"
        return 0
      else
        echo "✗ FAIL: $description"
        echo "  Condition: $condition"
        ASSERT_FAILURES=$((${ASSERT_FAILURES:-0} + 1))
        return 1
      fi
    }

    # Print test summary - call at end of script when TEST_MODE=true
    test_summary() {
      if [ "${TEST_MODE}" != "true" ]; then
        return 0
      fi

      echo ""
      echo "========================================="
      echo "Test Summary"
      echo "========================================="
      if [ "${ASSERT_FAILURES:-0}" -eq 0 ]; then
        echo "All assertions passed!"
        return 0
      else
        echo "FAILED: ${ASSERT_FAILURES} assertion(s) failed"
        return 1
      fi
    }

    # ============================================================================
    # DRY_RUN Mode Support
    # ============================================================================
    # When DRY_RUN=true, commands are printed but not executed
    # Useful for testing what would happen without making changes

    # Execute a command, respecting DRY_RUN mode
    # In DRY_RUN mode, prints the command instead of executing
    #
    # Args:
    #   $@ - Command and arguments to execute
    execute() {
      if [ "${DRY_RUN}" = "true" ]; then
        echo "[DRY_RUN] Would execute: $*"
        return 0
      fi
      "$@"
    }

    # ============================================================================
    # Core Helper Functions
    # ============================================================================

    # WP-CLI wrapper with optional debug output
    # Uses global DEBUG flag to control verbosity
    #
    # Args: All arguments are passed through to wp-cli
    #
    # Performance Note:
    #   Each wp call loads WordPress core - can be slow
    #   Use batch operations where possible (e.g., install multiple plugins at once)
    wp() {
      if [ "${DRY_RUN}" = "true" ]; then
        echo "[DRY_RUN] wp $*"
        return 0
      fi
      if [ "${DEBUG}" = "true" ]; then
        command wp --path="${WORDPRESS_PATH}" --debug "$@"
      else
        command wp --path="${WORDPRESS_PATH}" "$@"
      fi
    }

    # Run commands with optional output suppression based on DEBUG flag
    #
    # Args: Command and arguments to execute
    run() {
      if [ "${DRY_RUN}" = "true" ]; then
        echo "[DRY_RUN] $*"
        return 0
      fi
      if [ "${DEBUG}" = "true" ]; then
        "$@"
      else
        "$@" >/dev/null 2>&1
      fi
    }

    # Standardized error handler
    # Logs error message and exits with code 1
    #
    # Args:
    #   $1 - Error message to display
    handle_error() {
      echo "ERROR: $1" >&2
      exit 1
    }

    # Warning handler for non-fatal errors
    # Logs warning but allows script to continue
    #
    # Args:
    #   $1 - Warning message to display
    warn_and_continue() {
      echo "WARNING: $1" >&2
      return 0
    }

    # Retry wrapper for network operations with exponential backoff
    # Retries failed commands up to MAX_RETRIES times with increasing delays
    #
    # Args:
    #   $@ - Command and arguments to execute
    #
    # Returns:
    #   0 - Command succeeded (possibly after retries)
    #   1 - Command failed after all retries exhausted
    retry_command() {
      local max_retries=${MAX_RETRIES:-3}
      local retry_delay=${RETRY_DELAY:-2}
      local attempt=1
      local exit_code=0

      while [ $attempt -le $max_retries ]; do
        if "$@"; then
          return 0
        fi
        exit_code=$?

        if [ $attempt -lt $max_retries ]; then
          local wait_time=$((retry_delay * attempt))
          echo "Command failed (attempt $attempt/$max_retries), retrying in ${wait_time}s..." >&2
          sleep $wait_time
        fi

        attempt=$((attempt + 1))
      done

      echo "Command failed after $max_retries attempts" >&2
      return $exit_code
    }

    # Validate package name to prevent injection attacks
    # Checks for dangerous characters and patterns
    #
    # Args:
    #   $1 - Package name to validate
    #
    # Returns:
    #   0 - Package name is valid
    #   1 - Package name contains invalid characters
    validate_package_name() {
      local name="$1"

      # Check for empty name
      if [ -z "$name" ]; then
        echo "ERROR: Package name cannot be empty" >&2
        return 1
      fi

      # Check for dangerous characters (backticks, semicolons, pipes, etc.)
      if echo "$name" | grep -qE '[`;|&$()<>]'; then
        echo "ERROR: Package name contains invalid characters: $name" >&2
        return 1
      fi

      # Check for path traversal attempts
      if echo "$name" | grep -q '\.\.'; then
        echo "ERROR: Package name contains path traversal: $name" >&2
        return 1
      fi

      return 0
    }

    # ============================================================================
    # Fast Plugin/Theme List Functions (Direct Database Queries)
    # ============================================================================
    # Drop-in replacements for wp plugin list and wp theme list
    # 60x faster (~0.5s vs 30s) by using direct DB queries instead of loading WordPress

    # Fast plugin list using direct database query
    # Drop-in replacement for: wp plugin list --field=name --status=active/inactive
    #
    # Supports:
    #   --field=name (default)
    #   --status=active|inactive|any (default: any)
    #   --format=csv (with --fields for multiple columns)
    #
    # Performance: ~0.15s vs 30s for wp plugin list (200x faster)
    #
    # Args:
    #   $@ - Parameters (--field=X, --status=X, --format=X, --fields=X,Y)
    #
    # Examples:
    #   wp_plugin_list --field=name
    #   wp_plugin_list --status=active --field=name
    #   wp_plugin_list --fields=name,auto_update --format=csv
    wp_plugin_list() {
      local status="any"
      local field="name"
      local fields=""
      local format=""

      # Parse parameters
      for arg in "$@"; do
        case "$arg" in
          --status=*) status="${arg#*=}" ;;
          --field=*) field="${arg#*=}" ;;
          --fields=*) fields="${arg#*=}" ;;
          --format=*) format="${arg#*=}" ;;
        esac
      done

      # Get active plugins from DB (serialized PHP array)
      local active_plugins=$(wp db query "SELECT option_value FROM ${TABLE_PREFIX}options WHERE option_name='active_plugins';" --skip-column-names 2>/dev/null || echo "")

      # Get auto-update plugins from DB (serialized PHP array)
      local autoupdate_plugins=$(wp db query "SELECT option_value FROM ${TABLE_PREFIX}options WHERE option_name='auto_update_plugins';" --skip-column-names 2>/dev/null || echo "")

      # Find all installed plugins using filesystem
      local all_plugins=$(find "${WORDPRESS_PATH}/wp-content/plugins" -maxdepth 2 -name '*.php' -type f 2>/dev/null | while read plugin_file; do
        # Extract plugin slug from path (e.g., akismet/akismet.php -> akismet/akismet.php)
        local plugin_path="${plugin_file#${WORDPRESS_PATH}/wp-content/plugins/}"
        echo "$plugin_path"
      done | grep '/' || echo "")

      # Deserialize active plugins using PHP
      local active_list=""
      if [ -n "$active_plugins" ]; then
        active_list=$(echo "$active_plugins" | php -r 'while($line=fgets(STDIN)){$arr=@unserialize($line);if(is_array($arr)){foreach($arr as $p){echo $p."\n";}}}' 2>/dev/null || echo "")
      fi

      # Deserialize auto-update plugins using PHP
      local autoupdate_list=""
      if [ -n "$autoupdate_plugins" ]; then
        autoupdate_list=$(echo "$autoupdate_plugins" | php -r 'while($line=fgets(STDIN)){$arr=@unserialize($line);if(is_array($arr)){foreach($arr as $p){echo $p."\n";}}}' 2>/dev/null || echo "")
      fi

      # Filter by status and extract slug
      echo "$all_plugins" | while read plugin_path; do
        [ -z "$plugin_path" ] && continue

        # Extract slug (first part before /)
        local slug="${plugin_path%%/*}"

        # Check if active
        local is_active=false
        if echo "$active_list" | grep -qF "$plugin_path"; then
          is_active=true
        fi

        # Apply status filter
        if [ "$status" = "active" ] && [ "$is_active" = false ]; then
          continue
        fi
        if [ "$status" = "inactive" ] && [ "$is_active" = true ]; then
          continue
        fi

        # Output based on field/format
        if [ "$format" = "csv" ] && [ -n "$fields" ]; then
          # Multi-field CSV output
          local output_parts=()
          IFS=',' read -ra FIELD_ARRAY <<< "$fields"
          for f in "${FIELD_ARRAY[@]}"; do
            case "$f" in
              name) output_parts+=("$slug") ;;
              auto_update)
                if echo "$autoupdate_list" | grep -qF "$plugin_path"; then
                  output_parts+=("on")
                else
                  output_parts+=("off")
                fi
                ;;
            esac
          done
          # Join with commas
          local IFS=','
          echo "${output_parts[*]}"
        else
          # Single field output (default)
          case "$field" in
            name) echo "$slug" ;;
          esac
        fi
      done | sort -u
    }

    # Fast theme list using direct database query
    # Drop-in replacement for: wp theme list --field=name --status=active/inactive
    #
    # Supports:
    #   --field=name (default)
    #   --status=active|inactive|any (default: any)
    #   --format=csv (with --fields for multiple columns)
    #
    # Performance: ~0.10s vs 30s for wp theme list (300x faster)
    #
    # Args:
    #   $@ - Parameters (--field=X, --status=X, --format=X, --fields=X,Y)
    #
    # Examples:
    #   wp_theme_list --field=name
    #   wp_theme_list --status=active --field=name
    #   wp_theme_list --fields=name,auto_update --format=csv
    wp_theme_list() {
      local status="any"
      local field="name"
      local fields=""
      local format=""

      # Parse parameters
      for arg in "$@"; do
        case "$arg" in
          --status=*) status="${arg#*=}" ;;
          --field=*) field="${arg#*=}" ;;
          --fields=*) fields="${arg#*=}" ;;
          --format=*) format="${arg#*=}" ;;
        esac
      done

      # Get active theme from DB (stylesheet)
      local active_theme=$(wp db query "SELECT option_value FROM ${TABLE_PREFIX}options WHERE option_name='stylesheet';" --skip-column-names 2>/dev/null || echo "")

      # Get auto-update themes from DB (serialized PHP array)
      local autoupdate_themes=$(wp db query "SELECT option_value FROM ${TABLE_PREFIX}options WHERE option_name='auto_update_themes';" --skip-column-names 2>/dev/null || echo "")

      # Find all installed themes using filesystem
      local all_themes=$(find "${WORDPRESS_PATH}/wp-content/themes" -maxdepth 1 -mindepth 1 -type d 2>/dev/null | while read theme_dir; do
        basename "$theme_dir"
      done || echo "")

      # Deserialize auto-update themes using PHP
      local autoupdate_list=""
      if [ -n "$autoupdate_themes" ]; then
        autoupdate_list=$(echo "$autoupdate_themes" | php -r 'while($line=fgets(STDIN)){$arr=@unserialize($line);if(is_array($arr)){foreach($arr as $t){echo $t."\n";}}}' 2>/dev/null || echo "")
      fi

      # Filter by status and output
      echo "$all_themes" | while read theme_slug; do
        [ -z "$theme_slug" ] && continue

        # Check if active
        local is_active=false
        if [ "$theme_slug" = "$active_theme" ]; then
          is_active=true
        fi

        # Apply status filter
        if [ "$status" = "active" ] && [ "$is_active" = false ]; then
          continue
        fi
        if [ "$status" = "inactive" ] && [ "$is_active" = true ]; then
          continue
        fi

        # Output based on field/format
        if [ "$format" = "csv" ] && [ -n "$fields" ]; then
          # Multi-field CSV output
          local output_parts=()
          IFS=',' read -ra FIELD_ARRAY <<< "$fields"
          for f in "${FIELD_ARRAY[@]}"; do
            case "$f" in
              name) output_parts+=("$theme_slug") ;;
              auto_update)
                if echo "$autoupdate_list" | grep -qF "$theme_slug"; then
                  output_parts+=("on")
                else
                  output_parts+=("off")
                fi
                ;;
            esac
          done
          # Join with commas
          local IFS=','
          echo "${output_parts[*]}"
        else
          # Single field output (default)
          case "$field" in
            name) echo "$theme_slug" ;;
          esac
        fi
      done | sort -u
    }
  # ============================================================================
  # Library: Database Lock Functions (lib-lock.sh)
  # ============================================================================
  # Contains: claim_bootstrap_lock(), release_bootstrap_lock(), claim_config_lock(), release_config_lock()
  # Provides distributed locking for multi-pod deployments using database tables
  # Uses heartbeat mechanism: lock holder updates timestamp every 15s,
  # waiters consider lock stale if no heartbeat for 60s
  lib-lock.sh: |
    #!/bin/bash
    # WordPress Helm Chart - Database Lock Library
    # Provides distributed locking for multi-pod deployments
    #
    # Heartbeat-based locking:
    #   - Lock holder runs a background heartbeat (updates timestamp every 15s)
    #   - Waiters check: was lock updated in last 60s?
    #   - If no heartbeat for 60s → pod crashed → lock is stale
    #   - Same hostname (pod restart): Lock immediately overridden
    #   - Lock format: hostname-timestamp

    BOOTSTRAP_LOCK_ACQUIRED=false
    CONFIG_LOCK_ACQUIRED=false
    HEARTBEAT_PID=""
    readonly HEARTBEAT_INTERVAL=15  # Seconds between heartbeat updates
    readonly STALE_THRESHOLD=60     # Seconds without heartbeat before lock is considered stale
    readonly MAX_LOCK_WAIT=600      # Absolute max wait time in seconds (safety net)

    # Start heartbeat for a lock - updates timestamp every HEARTBEAT_INTERVAL seconds
    # Uses lightweight PHP directly instead of wp-cli to avoid resource contention
    # Args: $1 = lock type ("bootstrap" or "config")
    _start_heartbeat() {
      local lock_type="$1"
      local pod_hostname="$(hostname)"

      # Kill any existing heartbeat first
      _stop_heartbeat

      if [ "$lock_type" = "bootstrap" ]; then
        (
          while true; do
            sleep $HEARTBEAT_INTERVAL
            php -r "\$m = @new mysqli('${WORDPRESS_DB_HOST}', '${WORDPRESS_DB_USER}', '${WORDPRESS_DB_PASSWORD}', '${WORDPRESS_DB_NAME}'); if(!\$m->connect_error) { \$t=time(); \$m->query(\"UPDATE ${TABLE_PREFIX}helm_locks SET lock_value='${pod_hostname}-\".\$t.\"' WHERE lock_name='bootstrap' AND lock_value LIKE '${pod_hostname}-%'\"); \$m->close(); }" 2>/dev/null || true
          done
        ) &
      else
        (
          while true; do
            sleep $HEARTBEAT_INTERVAL
            php -r "\$m = @new mysqli('${WORDPRESS_DB_HOST}', '${WORDPRESS_DB_USER}', '${WORDPRESS_DB_PASSWORD}', '${WORDPRESS_DB_NAME}'); if(!\$m->connect_error) { \$t=time(); \$m->query(\"UPDATE ${TABLE_PREFIX}options SET option_value='${pod_hostname}-\".\$t.\"' WHERE option_name='_helm_config_lock' AND option_value LIKE '${pod_hostname}-%'\"); \$m->close(); }" 2>/dev/null || true
          done
        ) &
      fi
      HEARTBEAT_PID=$!
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Heartbeat started (PID: $HEARTBEAT_PID) for $lock_type lock" >&2
    }

    # Stop the heartbeat background process
    _stop_heartbeat() {
      if [ -n "$HEARTBEAT_PID" ]; then
        kill $HEARTBEAT_PID 2>/dev/null || true
        wait $HEARTBEAT_PID 2>/dev/null || true
        [ "${DEBUG}" = "true" ] && echo "DEBUG: Heartbeat stopped (PID: $HEARTBEAT_PID)" >&2
        HEARTBEAT_PID=""
      fi
    }

    # Attempt to claim bootstrap lock using dedicated helm_locks table
    # This is used BEFORE WordPress installation when wp_options doesn't exist yet
    #
    # Returns:
    #   0 - Lock successfully claimed (heartbeat started)
    #   1 - Lock held by another pod (after retries)
    #
    # Heartbeat: Lock holder updates timestamp every 15s.
    # Waiters check: no heartbeat for 60s → lock is stale → override.
    claim_bootstrap_lock() {
      local retry_interval=10
      local retry_count=0
      local max_retries=$((MAX_LOCK_WAIT / retry_interval))
      local pod_hostname="$(hostname)"
      local current_time=$(date +%s)

      echo "Attempting to claim bootstrap lock (for WordPress installation)..."
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Pod hostname: $pod_hostname" >&2

      while [ $retry_count -lt $max_retries ]; do
        current_time=$(date +%s)

        # Ensure helm_locks table exists on every attempt
        # (CREATE TABLE IF NOT EXISTS is idempotent and fast when table already exists)
        # This handles the case where MariaDB accepts connections but isn't fully ready for DDL yet
        wp db query "
          CREATE TABLE IF NOT EXISTS ${TABLE_PREFIX}helm_locks (
            lock_name VARCHAR(64) PRIMARY KEY,
            lock_value VARCHAR(255) NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
          );
        " >/dev/null 2>&1

        # Atomic lock claim: override if same hostname OR no heartbeat for STALE_THRESHOLD seconds
        wp db query "
          INSERT INTO ${TABLE_PREFIX}helm_locks (lock_name, lock_value)
          VALUES ('bootstrap', '$pod_hostname-$current_time')
          ON DUPLICATE KEY UPDATE
            lock_value = IF(
              lock_value LIKE '$pod_hostname-%'
              OR CAST(SUBSTRING_INDEX(lock_value, '-', -1) AS UNSIGNED) < $current_time - $STALE_THRESHOLD,
              '$pod_hostname-$current_time',
              lock_value
            );
        " >/dev/null 2>&1

        sleep 0.1

        # Check if we got the lock
        local lock_owner=$(wp db query "SELECT lock_value FROM ${TABLE_PREFIX}helm_locks WHERE lock_name='bootstrap';" --skip-column-names 2>/dev/null || echo "")

        if [[ "$lock_owner" == "$pod_hostname-$current_time" ]]; then
          echo "Bootstrap lock acquired successfully!"
          BOOTSTRAP_LOCK_ACQUIRED=true
          _start_heartbeat "bootstrap"
          return 0
        fi

        retry_count=$((retry_count + 1))
        if [ $retry_count -lt $max_retries ]; then
          local wait_time=$((retry_count * retry_interval))
          echo "Another pod is installing WordPress, waiting... (${wait_time}s)"
          sleep $retry_interval
        fi
      done

      echo "ERROR: Timeout waiting for bootstrap lock after ${MAX_LOCK_WAIT}s"
      return 1
    }

    # Release bootstrap lock and stop heartbeat
    release_bootstrap_lock() {
      if [ "$BOOTSTRAP_LOCK_ACQUIRED" = "true" ]; then
        _stop_heartbeat
        [ "${DEBUG}" = "true" ] && echo "DEBUG: Releasing bootstrap lock" >&2
        local pod_hostname="$(hostname)"
        wp db query "DELETE FROM ${TABLE_PREFIX}helm_locks WHERE lock_name='bootstrap' AND lock_value LIKE '$pod_hostname-%';" >/dev/null 2>&1 || true
        BOOTSTRAP_LOCK_ACQUIRED=false
        echo "Bootstrap lock released!"
      fi
    }

    # Attempt to claim configuration lock using wp_options table
    # This is used AFTER WordPress installation for plugin/theme/config management
    #
    # Returns:
    #   0 - Lock successfully claimed (heartbeat started)
    #   1 - Lock held by another pod (after retries)
    #
    # Heartbeat: Lock holder updates timestamp every 15s.
    # Waiters check: no heartbeat for 60s → lock is stale → override.
    claim_config_lock() {
      local retry_interval=10
      local retry_count=0
      local max_retries=$((MAX_LOCK_WAIT / retry_interval))
      local pod_hostname="$(hostname)"
      local current_time=$(date +%s)

      [ "${DEBUG}" = "true" ] && echo "DEBUG: Attempting config lock, hostname: $pod_hostname" >&2

      while [ $retry_count -lt $max_retries ]; do
        current_time=$(date +%s)

        # Atomic lock claim: override if same hostname OR no heartbeat for STALE_THRESHOLD seconds
        wp db query "
          INSERT INTO ${TABLE_PREFIX}options (option_name, option_value, autoload)
          VALUES ('_helm_config_lock', '$pod_hostname-$current_time', 'no')
          ON DUPLICATE KEY UPDATE
            option_value = IF(
              option_value LIKE '$pod_hostname-%'
              OR CAST(SUBSTRING_INDEX(option_value, '-', -1) AS UNSIGNED) < $current_time - $STALE_THRESHOLD,
              '$pod_hostname-$current_time',
              option_value
            );
        " >/dev/null 2>&1

        sleep 0.1

        # Check if we got the lock
        local lock_owner=$(wp db query "SELECT option_value FROM ${TABLE_PREFIX}options WHERE option_name='_helm_config_lock';" --skip-column-names 2>/dev/null || echo "")

        if [[ "$lock_owner" == "$pod_hostname-$current_time" ]]; then
          CONFIG_LOCK_ACQUIRED=true
          _start_heartbeat "config"
          [ "${DEBUG}" = "true" ] && echo "DEBUG: Pod $pod_hostname claimed config lock" >&2
          return 0
        fi

        # Lock held by another pod with fresh heartbeat
        retry_count=$((retry_count + 1))
        if [ $retry_count -lt $max_retries ]; then
          local wait_time=$((retry_count * retry_interval))
          echo "Another pod is running init process, waiting... (${wait_time}s)"
          sleep $retry_interval
        fi
      done

      [ "${DEBUG}" = "true" ] && echo "DEBUG: Timeout waiting for config lock after ${MAX_LOCK_WAIT}s" >&2
      return 1
    }

    # Release the configuration lock and stop heartbeat
    release_config_lock() {
      if [ "$CONFIG_LOCK_ACQUIRED" = "true" ]; then
        _stop_heartbeat
        [ "${DEBUG}" = "true" ] && echo "DEBUG: Releasing config lock" >&2
        local pod_hostname="$(hostname)"
        wp db query "DELETE FROM ${TABLE_PREFIX}options WHERE option_name='_helm_config_lock' AND option_value LIKE '$pod_hostname-%';" >/dev/null 2>&1 || true
        CONFIG_LOCK_ACQUIRED=false
        echo "Config lock released!"
      fi
    }
  # ============================================================================
  # Library: Composer Functions (lib-composer.sh)
  # ============================================================================
  # Contains: ensure_composer(), composer_exec()
  # Handles Composer installation and package management
  lib-composer.sh: |
    #!/bin/bash
    # WordPress Helm Chart - Composer Library
    # Provides Composer package management utilities

    # Install Composer on-demand to temporary directory
    # Downloads, verifies checksum, and installs to COMPOSER_INSTALL_DIR
    # Idempotent - skips if composer already available
    #
    # Performance Notes:
    #   - Downloads only happen once per pod lifetime
    #   - Uses retry logic for network resilience
    #   - Checksum verification prevents corrupted downloads
    ensure_composer() {
      # Set Composer home to writable directory
      export COMPOSER_HOME="${COMPOSER_HOME_DIR}"
      mkdir -p "$COMPOSER_HOME"

      if ! command -v composer &> /dev/null; then
        echo "Composer not found, installing..."
        cd "${COMPOSER_INSTALL_DIR}" || handle_error "Cannot access Composer install directory"

        # Download Composer installer with retry logic
        echo "  Downloading Composer installer..."
        if ! retry_command php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"; then
          handle_error "Failed to download Composer installer after retries"
        fi

        # Download and verify checksum with retry logic
        echo "  Verifying checksum..."
        if ! EXPECTED_CHECKSUM="$(retry_command php -r 'copy("https://composer.github.io/installer.sig", "php://stdout");')"; then
          rm -f composer-setup.php
          handle_error "Failed to download Composer checksum after retries"
        fi

        ACTUAL_CHECKSUM="$(php -r "echo hash_file('sha384', 'composer-setup.php');")"

        if [ "$EXPECTED_CHECKSUM" != "$ACTUAL_CHECKSUM" ]; then
          rm composer-setup.php
          handle_error "Invalid Composer installer checksum"
        fi

        # Install Composer to temporary location
        echo "  Running installer..."
        php composer-setup.php --quiet --install-dir="${COMPOSER_INSTALL_DIR}" --filename=composer 2>&1 | grep -v "PHP version" | grep -v "diagnose" || true
        rm composer-setup.php

        # Add to PATH for this session
        export PATH="${COMPOSER_INSTALL_DIR}:$PATH"

        echo "  Composer installed!"
      fi
    }

    # Execute composer command with proper environment
    # Wraps composer with DRY_RUN support
    #
    # Args:
    #   $@ - Composer command and arguments
    composer_exec() {
      if [ "${DRY_RUN}" = "true" ]; then
        echo "[DRY_RUN] composer $*"
        return 0
      fi
      composer "$@"
    }
  init.sh: |
    #!/bin/bash
    set -e

    # ============================================================================
    # WordPress Helm Chart Init Script
    # ============================================================================
    #
    # Purpose:
    #   Initializes WordPress installation with plugins, themes, and configuration.
    #   Ensures safe multi-pod deployment using distributed database locking.
    #
    # Features:
    #   - Modular library architecture for maintainability
    #   - Atomic database lock prevents concurrent initialization
    #   - Composer package management for plugins/themes
    #   - Automatic dependency installation and autoloading
    #   - Network retry logic with exponential backoff
    #   - Input validation and injection protection
    #   - Performance optimizations (caching, batch operations)
    #   - DRY_RUN mode for testing without changes
    #   - TEST_MODE with assertions for validation
    #
    # Libraries:
    #   - lib-core.sh: Core utilities (wp, run, handle_error, retry_command, assert)
    #   - lib-lock.sh: Database locking with heartbeat (claim/release bootstrap + config locks)
    #   - lib-composer.sh: Composer management (ensure_composer, composer_exec)
    #
    # Environment Variables:
    #   WP_INIT - Enable/disable WordPress core installation
    #   WP_URL - WordPress site URL
    #   WP_TITLE - Site title
    #   WP_ADMIN_USER - Admin username
    #   WP_ADMIN_PASSWORD - Admin password
    #   WP_ADMIN_EMAIL - Admin email
    #   WP_LOCALE - WordPress language locale
    #   DEBUG - Enable verbose debug output (true/false)
    #   DRY_RUN - Print commands without executing (true/false)
    #   TEST_MODE - Enable assertions for testing (true/false)
    #   MAX_RETRIES - Network operation retry count (default: 3)
    #   RETRY_DELAY - Base retry delay in seconds (default: 2)
    #
    # Exit Codes:
    #   0 - Successful initialization
    #   1 - Fatal error (database, lock timeout, invalid input, network failure)
    #
    # ============================================================================

    echo "Starting init script..."

    # ============================================================================
    # Load Libraries
    # ============================================================================
    # Libraries are copied to /tmp/lib by the base init container

    LIB_DIR="/tmp/lib"

    # Source libraries with error handling
    for lib in lib-core.sh lib-lock.sh lib-composer.sh; do
      if [ -f "$LIB_DIR/$lib" ]; then
        # shellcheck source=/dev/null
        source "$LIB_DIR/$lib"
        [ "${DEBUG}" = "true" ] && echo "DEBUG: Loaded library: $lib" >&2
      else
        echo "ERROR: Required library not found: $LIB_DIR/$lib" >&2
        echo "Make sure the base init container has prepared the libraries." >&2
        exit 1
      fi
    done

    # ============================================================================
    # Configuration Constants
    # ============================================================================

    # Database lock configuration
    readonly DB_CHECK_RETRY_INTERVAL=15  # Seconds between database connection checks

    # WordPress paths
    readonly WORDPRESS_PATH="/var/www/html"
    readonly WP_PLUGINS_DIR="wp-content/plugins"
    readonly WP_THEMES_DIR="wp-content/themes"
    readonly WP_MU_PLUGINS_DIR="wp-content/mu-plugins"

    # Composer configuration
    readonly COMPOSER_HOME_DIR="/tmp/.composer"
    readonly COMPOSER_INSTALL_DIR="/tmp"

    # Runtime variables
    COMPOSER_PACKAGES_MODIFIED=false
    COMPOSER_PLUGINS_PENDING_ACTIVATION=()
    ASSERT_FAILURES=0

    # Setup exit trap for lock release and heartbeat cleanup
    trap '_stop_heartbeat; release_bootstrap_lock; release_config_lock' EXIT

    # ============================================================================
    # Wait for Database
    # ============================================================================


    echo "Waiting for database..."
    # Direct database connection check (faster than wp db check - no WordPress bootstrap)
    until php -r "\$m = @new mysqli('${WORDPRESS_DB_HOST}', '${WORDPRESS_DB_USER}', '${WORDPRESS_DB_PASSWORD}', '${WORDPRESS_DB_NAME}'); exit(\$m->connect_error ? 1 : 0);" 2>/dev/null; do
      echo "Database not ready yet, waiting ${DB_CHECK_RETRY_INTERVAL} seconds..."
      sleep "${DB_CHECK_RETRY_INTERVAL}"
    done
    echo "Database connection established!"

    # Cache table prefix once (performance optimization)
    # Priority: 1. Environment variable (from values.yaml), 2. wp-config.php, 3. default "wp_"
    if [ -n "${WORDPRESS_TABLE_PREFIX}" ]; then
      TABLE_PREFIX="${WORDPRESS_TABLE_PREFIX}"
    elif [ -f /var/www/html/wp-config.php ]; then
      TABLE_PREFIX=$(grep "^\$table_prefix" /var/www/html/wp-config.php 2>/dev/null | sed "s/.*'\([^']*\)'.*/\1/" || echo "wp_")
    else
      TABLE_PREFIX="wp_"
    fi
    export TABLE_PREFIX
    echo "Using WordPress table prefix: ${TABLE_PREFIX}"

    # ============================================================================
    # Bootstrap Lock Acquisition (Before WordPress Installation)
    # ============================================================================
    # This lock prevents race conditions when multiple pods start simultaneously
    # and try to install WordPress at the same time.
    #
    # Uses dedicated helm_locks table with heartbeat-based stale detection.

    # Check if WordPress is already installed (quick check before claiming lock)
    WP_ALREADY_INSTALLED=false
    if wp db query "SHOW TABLES LIKE '${TABLE_PREFIX}options';" --skip-column-names 2>/dev/null | grep -q "${TABLE_PREFIX}options"; then
      if run wp core is-installed --url="${WP_URL}" 2>/dev/null; then
        WP_ALREADY_INSTALLED=true
        echo "WordPress is already installed, skipping bootstrap lock."
      fi
    fi

    # Only claim bootstrap lock if WordPress needs installation
    if [ "$WP_ALREADY_INSTALLED" = "false" ] && [ "${WP_INIT}" = "true" ]; then
      echo "WordPress not installed yet, claiming bootstrap lock..."
      if ! claim_bootstrap_lock; then
        echo "ERROR: Failed to claim bootstrap lock - another pod may have installation issues"
        exit 1
      fi
      # Trap already set up above with _stop_heartbeat + release functions
    fi

    # ============================================================================
    # WordPress Installation (First-Time Only)
    # ============================================================================

    echo "========================================="
    echo "Setting up WordPress..."
    echo "========================================="

    if [ "${WP_INIT}" = "true" ]; then
      # Check both: wp-cli installation status AND database tables existence
      WP_INSTALLED=false
      if run wp core is-installed --url="${WP_URL}" 2>/dev/null; then
        # wp-cli says installed, but verify tables actually exist
        if wp db query "SHOW TABLES LIKE '${TABLE_PREFIX}options';" --skip-column-names 2>/dev/null | grep -q "${TABLE_PREFIX}options"; then
          WP_INSTALLED=true
          echo "WordPress is already installed, skipping installation."
        else
          echo "WordPress files exist but database tables are missing - reinstalling..."
          WP_INSTALLED=false
        fi
      fi

      if [ "$WP_INSTALLED" = "false" ]; then
        echo "Installing WordPress core..."
        run wp core install \
          --url="${WP_URL}" \
          --title="${WP_TITLE}" \
          --admin_user="${WP_ADMIN_USER}" \
          --admin_password="${WP_ADMIN_PASSWORD}" \
          --admin_email="${WP_ADMIN_EMAIL}" \
          --skip-email \
          --locale="${WP_LOCALE}"

        # Verify installation succeeded
        if ! wp db query "SHOW TABLES LIKE '${TABLE_PREFIX}options';" --skip-column-names 2>/dev/null | grep -q "${TABLE_PREFIX}options"; then
          echo "ERROR: WordPress installation failed - wp_options table not created!"
          exit 1
        fi
        echo "WordPress core installed successfully!"

        # Release bootstrap lock after successful installation
        release_bootstrap_lock
      else
        # Installation was skipped, release bootstrap lock if acquired
        release_bootstrap_lock
      fi
    else
      # WP_INIT is false - check if WordPress is already installed
      # Use cached TABLE_PREFIX (set at script start)

      # Check if wp_options table exists
      if ! wp db query "SHOW TABLES LIKE '${TABLE_PREFIX}options';" --skip-column-names 2>/dev/null | grep -q "${TABLE_PREFIX}options"; then
        echo "========================================="
        echo "ERROR: WordPress database tables not found!"
        echo "========================================="
        echo ""
        echo "The database exists but WordPress tables are missing."
        echo "This indicates one of the following issues:"
        echo ""
        echo "1. WordPress initialization has not been performed yet"
        echo "   -> Set wordpress.init.enabled=true in your values.yaml"
        echo ""
        echo "2. Wrong table prefix configured"
        echo "   -> Current prefix: ${TABLE_PREFIX}"
        echo "   -> Check wordpress.tablePrefix in your values.yaml"
        echo ""
        echo "3. Database was reset but persistent volume still exists"
        echo "   -> Delete the PVC and reinstall"
        echo ""
        echo "========================================="
        exit 1
      fi


      echo "WordPress tables found, continuing with configuration..."
    fi


    # ============================================================================
    # Acquire Configuration Lock
    # Ensures only one pod performs plugin/theme/config initialization at a time
    # ============================================================================

    echo "Acquiring configuration lock for initialization..."
    if ! claim_config_lock; then
      echo "ERROR: Timeout waiting for configuration lock after ${MAX_LOCK_WAIT}s"
      echo "Another pod may be stuck. Check its logs for errors."
      exit 1
    fi

    echo "Configuration lock acquired, proceeding with initialization..."

    # ============================================================================
    # Disable WordPress Core Auto-Updates (managed by Helm chart via image updates)
    # ============================================================================

    # Only run if wp_options table exists (skip for fresh installs without WP_INIT=true)
    if wp db query "SHOW TABLES LIKE '${TABLE_PREFIX}options';" --skip-column-names 2>/dev/null | grep -q "${TABLE_PREFIX}options"; then
      echo "Disabling WordPress core auto-updates..."
      # Update all 3 settings in one multi-row query (faster than 3 separate queries)
      wp db query "
        INSERT INTO ${TABLE_PREFIX}options (option_name, option_value, autoload) VALUES
          ('auto_update_core_dev', 'disabled', 'yes'),
          ('auto_update_core_minor', 'disabled', 'yes'),          ('auto_update_core_major', 'disabled', 'yes')
        ON DUPLICATE KEY UPDATE option_value='disabled';
      " 2>&1 | grep -v -e "^$" -e "^Success:" || true
      echo "Core auto-updates disabled!"
    else
      echo "Skipping WordPress configuration (database tables not ready yet)"
      # Skip all DB-dependent configuration if tables don't exist
      {{- if .Values.wordpress.users }}
      echo "Skipping custom user creation (database not ready)"
      {{- end }}
      echo "Continuing to plugin/theme management..."
      exit 0  # Exit early, WordPress needs to be set up first
    fi

    # ============================================================================
    # WordPress Configuration (Localization, Permalinks, User Metadata)
    # ============================================================================


    if [ "${WP_INIT}" = "true" ]; then
      # Set language (with single check)
      if [ -n "${WP_LOCALE}" ]; then
        LANG_STATUS=$(wp language core list --language=${WP_LOCALE} --field=status 2>/dev/null || echo "uninstalled")
        case $LANG_STATUS in
          "uninstalled")
            echo "Installing language pack: ${WP_LOCALE}..."
            wp language core install ${WP_LOCALE} --activate
            ;;
          "installed")
            wp site switch-language ${WP_LOCALE}
            ;;
        esac

        # Check if language pack update is available (single check)
        LANG_UPDATE=$(wp language core list --language=${WP_LOCALE} --field=update 2>/dev/null || echo "none")
        if [ "$LANG_UPDATE" = "available" ]; then
          echo "Updating language pack for ${WP_LOCALE}..."
          wp language core update || true
        fi
      fi

      # Set permalinks (direct DB query - faster than wp-cli)
      if [ -n "${WP_PERMALINK_STRUCTURE}" ]; then
        CURRENT_PERMALINK=$(wp db query "SELECT option_value FROM ${TABLE_PREFIX}options WHERE option_name='permalink_structure';" --skip-column-names 2>/dev/null || echo "")
        if [ "$CURRENT_PERMALINK" != "$WP_PERMALINK_STRUCTURE" ]; then
          echo "Setting WordPress permalinks to: ${WP_PERMALINK_STRUCTURE}"
          # Update or insert permalink structure directly in database
          wp db query "INSERT INTO ${TABLE_PREFIX}options (option_name, option_value, autoload) VALUES ('permalink_structure', '${WP_PERMALINK_STRUCTURE}', 'yes') ON DUPLICATE KEY UPDATE option_value='${WP_PERMALINK_STRUCTURE}';" >/dev/null 2>&1
          # Delete rewrite_rules to force WordPress to regenerate them on next page load
          wp db query "DELETE FROM ${TABLE_PREFIX}options WHERE option_name='rewrite_rules';" >/dev/null 2>&1 || true
          echo "Permalink structure updated (rewrite rules will be regenerated automatically)"
        fi
      fi

      # Set admin user metadata
      if [ -n "${WP_ADMIN_FIRSTNAME}" ]; then
        CURRENT_FIRSTNAME=$(wp user meta get "$WP_ADMIN_USER" first_name 2>/dev/null || echo "")
        if [ "$CURRENT_FIRSTNAME" != "$WP_ADMIN_FIRSTNAME" ]; then
          echo "Setting admin first name..."
          wp user meta update "$WP_ADMIN_USER" first_name "$WP_ADMIN_FIRSTNAME"
        fi
      fi
      if [ -n "${WP_ADMIN_LASTNAME}" ]; then
        CURRENT_LASTNAME=$(wp user meta get "$WP_ADMIN_USER" last_name 2>/dev/null || echo "")
        if [ "$CURRENT_LASTNAME" != "$WP_ADMIN_LASTNAME" ]; then
          echo "Setting admin last name..."
          wp user meta update "$WP_ADMIN_USER" last_name "$WP_ADMIN_LASTNAME"
        fi
      fi
    fi


    # ============================================================================
    # Create Custom Users
    # ============================================================================


    {{- if .Values.wordpress.users }}
    echo "Creating custom users..."
    EXISTING_USERS=$(wp user list --field=user_login 2>/dev/null || echo "")


    {{- range .Values.wordpress.users }}
    if ! echo "$EXISTING_USERS" | grep -q "^{{ .username }}$"; then
      echo "Creating user {{ .username }}..."
      run wp user create "{{ .username }}" "{{ .email }}" \
        --role="{{ .role }}" \
        --display_name="{{ .displayname }}" \
        --first_name="{{ .firstname }}" \
        --last_name="{{ .lastname }}" \
        --send-email="{{ .sendEmail }}"
    else
      echo "User {{ .username }} already exists, skipping."
    fi
    {{- end }}
    {{- else }}
    echo "No custom users specified."
    {{- end }}

    # ============================================================================
    # Composer Configuration
    # ============================================================================

    # Only initialize Composer if we have Composer packages to install
    {{- if or .Values.wordpress.plugins .Values.wordpress.themes }}
    HAS_COMPOSER_PACKAGES=false
    {{- if .Values.wordpress.plugins }}
    {{- range .Values.wordpress.plugins }}
    {{- $name := .name }}
    {{- if and (contains "/" $name) (not (hasPrefix "http://" $name)) (not (hasPrefix "https://" $name)) }}
    HAS_COMPOSER_PACKAGES=true
    {{- end }}
    {{- end }}
    {{- end }}
    {{- if .Values.wordpress.themes }}
    {{- range .Values.wordpress.themes }}
    {{- $name := .name }}
    {{- if and (contains "/" $name) (not (hasPrefix "http://" $name)) (not (hasPrefix "https://" $name)) }}
    HAS_COMPOSER_PACKAGES=true
    {{- end }}
    {{- end }}
    {{- end }}

    if [ "$HAS_COMPOSER_PACKAGES" = "true" ]; then
      echo "========================================="
      echo "Setting up Composer configuration..."
      echo "========================================="
      ensure_composer
      cd /var/www/html || handle_error "Failed to change to /var/www/html directory"

      # Track if any Composer packages were installed/updated (to run composer install later)
      COMPOSER_PACKAGES_MODIFIED=false

      # Initialize composer.json if it doesn't exist
      if [ ! -f composer.json ]; then
        echo "Creating composer.json..."
        cat > composer.json << 'COMPOSERJSON'
    {
      "name": "wordpress/site",
      "description": "WordPress site managed by Helm",
      "type": "project",
      "require": {},
      "repositories": [
        {
          "type": "composer",
          "url": "https://wpackagist.org"
        }{{- if .Values.wordpress.composer.repositories }}{{- range .Values.wordpress.composer.repositories }},
        {
          "type": "{{ .type }}",
          "url": "{{ .url }}"{{- if .options }},
          "options": {{ .options | toJson }}{{- end }}
        }{{- end }}{{- end }}
      ],
      "extra": {
        "installer-paths": {
          "wp-content/plugins/{$name}/": ["type:wordpress-plugin"],
          "wp-content/themes/{$name}/": ["type:wordpress-theme"]
        }
      },
      "config": {
        "allow-plugins": {
          "composer/installers": true
        }
      }
    }
    COMPOSERJSON
        echo "composer.json created!"
      else
        [ "${DEBUG}" = "true" ] && echo "DEBUG: composer.json already exists"
        {{- if .Values.wordpress.composer }}
        # Update repositories in existing composer.json
        [ "${DEBUG}" = "true" ] && echo "DEBUG: Updating custom repositories..."

        # Build JSON array of custom repositories
        CUSTOM_REPOS='[{{- range $index, $repo := .Values.wordpress.composer.repositories }}{{- if $index }},{{- end }}{{ $repo | toJson }}{{- end }}]'

        # Use PHP to merge repositories (wpackagist + custom repos)
        export CUSTOM_REPOS
        TEMP_JSON=$(cat composer.json | php -r '
          $json = json_decode(file_get_contents("php://stdin"), true);
          $customReposJson = getenv("CUSTOM_REPOS");
          $customRepos = json_decode($customReposJson, true);

          // Remove any numeric keys that might have been added by mistake (only at top level)
          $cleanJson = [];
          foreach ($json as $key => $value) {
            if (!is_numeric($key)) {
              $cleanJson[$key] = $value;
            }
          }
          $json = $cleanJson;

          // Keep wpackagist repo
          $wpackagist = ["type" => "composer", "url" => "https://wpackagist.org"];

          // Build repositories array (wpackagist + custom repos)
          $repos = [$wpackagist];
          if (is_array($customRepos) && !empty($customRepos)) {
            foreach ($customRepos as $repo) {
              if (is_array($repo)) {
                $repos[] = $repo;
              }
            }
          }
          $json["repositories"] = $repos;

          // Ensure allow-plugins config is preserved/set
          if (!isset($json["config"])) {
            $json["config"] = [];
          }
          if (!isset($json["config"]["allow-plugins"])) {
            $json["config"]["allow-plugins"] = [];
          }
          $json["config"]["allow-plugins"]["composer/installers"] = true;

          echo json_encode($json, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
        ')

        echo "$TEMP_JSON" > composer.json
        [ "${DEBUG}" = "true" ] && echo "DEBUG: Custom repositories updated!"
        {{- end }}
      fi

      # Set allow-plugins config before requiring composer/installers
      composer config --no-plugins allow-plugins.composer/installers true

      # Ensure composer/installers is available for installer-paths
      if ! composer show composer/installers &>/dev/null; then
        echo "Installing composer/installers..."
        composer require composer/installers --no-interaction --quiet 2>&1 | grep -v "suggest" | grep -v "funding" || true
      fi
    fi
    {{- end }}

    # ============================================================================
    # Plugin Management
    # ============================================================================
    #
    # Process Overview:
    #   1. Cache plugin lists upfront (avoid repeated wp-cli calls)
    #   2. Detect package type (Composer vs WP repository vs URL)
    #   3. Validate package names for security
    #   4. Batch operations for performance
    #   5. Install with retry logic for network resilience
    #   6. Activate and configure auto-updates
    #
    # Performance Optimizations:
    #   - Batch installation (wp plugin install plugin1 plugin2 plugin3)
    #   - Cached plugin lists (single wp-cli call)
    #   - Skip already installed packages
    #
    # Error Handling:
    #   - Validation errors: Skip package with warning
    #   - Network errors: Retry with exponential backoff
    #   - Composer errors: Exit with detailed message

    # Cache all plugin data upfront for performance (using fast DB queries)
    echo "Caching plugin data..."
    INSTALLED_PLUGINS=$(wp_plugin_list --field=name 2>/dev/null || echo "")
    ACTIVE_PLUGINS=$(wp_plugin_list --status=active --field=name 2>/dev/null || echo "")
    AUTOUPDATE_ENABLED=$(wp_plugin_list --fields=name,auto_update --format=csv 2>/dev/null | grep ",on$" | cut -d',' -f1 || echo "")

    # Detect if a name is a Composer package (vendor/package format)
    #
    # Args:
    #   $1 - Package name to check
    #
    # Returns:
    #   0 - Is a Composer package (contains / but not URL)
    #   1 - Not a Composer package
    #
    # Performance:
    #   String pattern matching (fast, no subprocess)
    #
    # Examples:
    #   is_composer_package "wpackagist-plugin/akismet" -> 0 (true)
    #   is_composer_package "akismet" -> 1 (false)
    #   is_composer_package "https://example.com/plugin.zip" -> 1 (false)
    is_composer_package() {
      local name="$1"
      # Check if it contains / and doesn't start with http:// or https://
      if [[ "$name" == */* ]] && [[ "$name" != http://* ]] && [[ "$name" != https://* ]]; then
        return 0
      fi
      return 1
    }

    # Extract WordPress slug from Composer package name
    # Example: wpackagist-plugin/akismet -> akismet
    #
    # Args:
    #   $1 - Composer package name (vendor/package)
    #
    # Returns:
    #   Package portion after the slash
    get_composer_slug() {
      local package="$1"
      # Extract part after the /
      echo "${package##*/}"
    }

    # Handle metrics plugin
    if [ -n "${WORDPRESS_METRICS}" ]; then
      if echo "$INSTALLED_PLUGINS" | grep -q "^${WORDPRESS_METRICS}$"; then
        if ! echo "$ACTIVE_PLUGINS" | grep -q "^${WORDPRESS_METRICS}$"; then
          wp plugin activate ${WORDPRESS_METRICS} 2>/dev/null || true
          PLUGINS_MODIFIED=true
        fi
      else
        echo "Installing WordPress metrics plugin..."
        wp plugin install ${WORDPRESS_METRICS} --activate --force
        PLUGINS_MODIFIED=true
      fi

    else
      # Remove plugin if WORDPRESS_METRICS is empty and plugin exists
      if [ -n "${WORDPRESS_METRICS}" ] && [ -n "$INSTALLED_PLUGINS" ] && echo "$INSTALLED_PLUGINS" | grep -q "^${WORDPRESS_METRICS}$"; then
        echo "Removing metrics plugin..."
        wp plugin delete ${WORDPRESS_METRICS}
        PLUGINS_MODIFIED=true
      fi
    fi

    # ============================================================================
    # Plugin Management
    # ============================================================================
    #
    # Process Overview:
    #   1. Detect package type (Composer vs WP repository vs URL)
    #   2. Validate package names for security
    #   3. Batch operations for performance
    #   4. Install with retry logic for network resilience
    #   5. Activate and configure auto-updates
    #
    # Performance Optimizations:
    #   - Batch installation (wp plugin install plugin1 plugin2 plugin3)
    #   - Cached plugin lists (avoid repeated wp-cli calls)
    #   - Skip already installed packages
    #
    # Error Handling:
    #   - Validation errors: Skip package with warning
    #   - Network errors: Retry with exponential backoff
    #   - Composer errors: Exit with detailed message
    #
    # Handle custom plugins
    {{- if .Values.wordpress.plugins }}
    echo "========================================="
    echo "Processing plugins..."
    echo "========================================="

    PLUGINS_TO_INSTALL=()
    PLUGINS_TO_ACTIVATE=()
    PLUGINS_TO_AUTOUPDATE=()

    COMPOSER_PLUGINS_TO_INSTALL=()
    COMPOSER_PLUGINS_TO_ACTIVATE=()
    COMPOSER_PLUGINS_TO_UPDATE=()

    {{- range .Values.wordpress.plugins }}
    # Plugin: {{ .name | lower }}
    PLUGIN_NAME="{{ .name | lower }}"

    # Validate package name before processing
    if ! validate_package_name "$PLUGIN_NAME"; then
      echo "Skipping invalid plugin name: $PLUGIN_NAME"
      continue
    fi

    # Check if it's a Composer package
    if is_composer_package "$PLUGIN_NAME"; then
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Detected Composer package: $PLUGIN_NAME"
      COMPOSER_SLUG=$(get_composer_slug "$PLUGIN_NAME")

      # Check if already installed via composer.json AND plugin directory exists
      # Plugin might be in composer.json but files deleted (e.g., after pruning)
      if [ -f /var/www/html/composer.json ] && grep -q "\"$PLUGIN_NAME\"" /var/www/html/composer.json 2>/dev/null; then
        if [ -d "/var/www/html/${WP_PLUGINS_DIR}/${COMPOSER_SLUG}" ]; then
          [ "${DEBUG}" = "true" ] && echo "DEBUG: Composer package $PLUGIN_NAME already installed"

          {{- if .autoupdate }}
          {{- if not .version }}
          # Auto-update only works for packages without fixed version AND already installed
          COMPOSER_PLUGINS_TO_UPDATE+=("$PLUGIN_NAME")
          {{- else }}
          echo "Note: Auto-update skipped for $PLUGIN_NAME (fixed version specified)"
          {{- end }}
          {{- end }}
        else
          # Package in composer.json but files missing - need to run composer install
          echo "Composer package $PLUGIN_NAME in composer.json but plugin directory missing - will reinstall"
          COMPOSER_PACKAGES_MODIFIED=true
        fi
      else
        {{- if .version }}
        COMPOSER_PLUGINS_TO_INSTALL+=("{{ .name | lower }}:{{ .version }}")
        {{- else }}
        COMPOSER_PLUGINS_TO_INSTALL+=("$PLUGIN_NAME")
        {{- end }}
      fi

      {{- if .activate }}
      COMPOSER_PLUGINS_TO_ACTIVATE+=("$COMPOSER_SLUG")
      {{- end }}
    # Check if it's a URL (at runtime, not template time)
    elif [[ "$PLUGIN_NAME" == http://* ]] || [[ "$PLUGIN_NAME" == https://* ]]; then
      echo "Installing URL plugin: $PLUGIN_NAME"
      {{- if .activate }}
      run wp plugin install "$PLUGIN_NAME" --activate --force
      {{- else }}
      run wp plugin install "$PLUGIN_NAME" --force
      {{- end }}
      # Note: Auto-updates for URL plugins are skipped (slug cannot be reliably determined)
    else
      # Named plugin - add to batch processing
      if ! echo "$INSTALLED_PLUGINS" | grep -q "^${PLUGIN_NAME}$"; then
        {{- if .version }}
        PLUGINS_TO_INSTALL+=("{{ .name | lower }}:{{ .version }}")
        {{- else }}
        PLUGINS_TO_INSTALL+=("{{ .name | lower }}")
        {{- end }}
      fi
      {{- if .activate }}
      PLUGINS_TO_ACTIVATE+=("{{ .name | lower }}")
      {{- end }}
      {{- if .autoupdate }}
      PLUGINS_TO_AUTOUPDATE+=("{{ .name | lower }}")
      {{- end }}
    fi
    {{- end }}

    # Batch install plugins
    if [ ${#PLUGINS_TO_INSTALL[@]} -gt 0 ]; then
      echo "Installing ${#PLUGINS_TO_INSTALL[@]} plugin(s)..."


      PLUGINS_NO_VERSION=()
      PLUGINS_WITH_VERSION=()


      for plugin_spec in "${PLUGINS_TO_INSTALL[@]}"; do
        if [[ "$plugin_spec" == *":"* ]]; then
          PLUGINS_WITH_VERSION+=("$plugin_spec")
        else
          PLUGINS_NO_VERSION+=("$plugin_spec")
        fi
      done


      if [ ${#PLUGINS_NO_VERSION[@]} -gt 0 ]; then
        retry_command wp plugin install "${PLUGINS_NO_VERSION[@]}" --force || echo "Warning: Some plugins failed to install"
      fi


      for plugin_spec in "${PLUGINS_WITH_VERSION[@]}"; do
        PLUGIN_NAME="${plugin_spec%%:*}"
        PLUGIN_VERSION="${plugin_spec##*:}"
        retry_command wp plugin install "${PLUGIN_NAME}" --version="${PLUGIN_VERSION}" --force || echo "Warning: Failed to install plugin: ${PLUGIN_NAME}"
      done


      INSTALLED_PLUGINS=$(wp_plugin_list --field=name 2>/dev/null || echo "")
      ACTIVE_PLUGINS=$(wp_plugin_list --status=active --field=name 2>/dev/null || echo "")
    fi

    # Install Composer plugins (batch operation for performance)
    if [ ${#COMPOSER_PLUGINS_TO_INSTALL[@]} -gt 0 ]; then
      echo "Installing ${#COMPOSER_PLUGINS_TO_INSTALL[@]} Composer plugin(s)..."
      cd /var/www/html || handle_error "Failed to change to /var/www/html directory"

      # Try batch install first (faster: single dependency resolution)
      all_packages="${COMPOSER_PLUGINS_TO_INSTALL[@]}"
      echo "Attempting batch install: $all_packages"

      if COMPOSER_OUTPUT=$(retry_command composer require $all_packages --no-interaction 2>&1); then
        echo "Batch install successful!"
      else
        echo "Batch install failed, falling back to individual installs..."
        echo "$COMPOSER_OUTPUT"

        # Fallback: Install individually
        for package_spec in "${COMPOSER_PLUGINS_TO_INSTALL[@]}"; do
          echo "Installing Composer package: $package_spec"
          if ! COMPOSER_OUTPUT=$(retry_command composer require "$package_spec" --no-interaction 2>&1); then
            echo "$COMPOSER_OUTPUT"
            handle_error "Error installing Composer package: $package_spec (failed after retries)"
          fi
        done
      fi

      echo "Composer plugins installed!"
      COMPOSER_PACKAGES_MODIFIED=true
      # Don't refresh plugin lists here - will do single refresh later
    fi

    # Update Composer plugins (auto-update for packages without fixed version)
    if [ ${#COMPOSER_PLUGINS_TO_UPDATE[@]} -gt 0 ]; then
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Checking for Composer plugin updates..."
      cd /var/www/html || handle_error "Failed to change to /var/www/html directory"

      # Get list of outdated packages once (performance optimization)
      OUTDATED_PACKAGES=$(composer outdated --direct --format=json 2>/dev/null | php -r '
        $json = json_decode(file_get_contents("php://stdin"), true);
        if (isset($json["installed"])) {
          foreach ($json["installed"] as $pkg) {
            echo $pkg["name"] . "\n";
          }
        }
      ' 2>/dev/null || echo "")

      PLUGINS_UPDATED=0
      for package in "${COMPOSER_PLUGINS_TO_UPDATE[@]}"; do
        # Check if package has an available update
        if echo "$OUTDATED_PACKAGES" | grep -q "^${package}$"; then
          echo "Updating Composer package: $package"
          # Capture output and only show on error, with retry logic
          if ! COMPOSER_OUTPUT=$(retry_command composer update "$package" --no-interaction 2>&1); then
            echo "$COMPOSER_OUTPUT"
            handle_error "Error updating Composer package: $package (failed after retries)"
          fi
          PLUGINS_UPDATED=$((PLUGINS_UPDATED + 1))
        else
          [ "${DEBUG}" = "true" ] && echo "DEBUG: Package $package is already up to date" >&2
        fi
      done

      if [ $PLUGINS_UPDATED -gt 0 ]; then
        echo "$PLUGINS_UPDATED Composer plugin(s) updated!"
        COMPOSER_PACKAGES_MODIFIED=true
      fi
    fi

    # Install Composer dependencies for plugins NOW (before theme installation)
    # This ensures plugins like s3-uploads have their dependencies (e.g., AWS SDK)
    # available before WordPress loads them during theme installation
    # Always run this section to ensure plugin dependencies are installed, even if
    # packages were not modified in this run (e.g., for existing installations)
    echo ""
    echo "========================================="
    echo "Checking plugin Composer dependencies..."
    echo "========================================="
    cd /var/www/html || handle_error "Failed to change to /var/www/html directory"

    # Run composer install for main project first (only if composer.json exists and was modified)
    if [ -f composer.json ] && { [ "$COMPOSER_PACKAGES_MODIFIED" = "true" ] || [ ${#COMPOSER_PLUGINS_TO_INSTALL[@]} -gt 0 ]; }; then
      if ! COMPOSER_OUTPUT=$(retry_command composer install --no-interaction 2>&1 | grep -v "suggest" | grep -v "funding"); then
        echo "$COMPOSER_OUTPUT"
        handle_error "Error installing Composer dependencies (failed after retries)"
      fi
    fi

      # Build list of Composer-installed plugin slugs
      COMPOSER_PLUGIN_SLUGS=""
      if [ -f composer.json ]; then
        COMPOSER_PLUGIN_SLUGS=$(php -r '
          $json = json_decode(file_get_contents("composer.json"), true);
          if (isset($json["require"])) {
            foreach ($json["require"] as $package => $version) {
              if (strpos($package, "/") !== false && $package !== "composer/installers") {
                $slug = substr($package, strrpos($package, "/") + 1);
                echo $slug . "\n";
              }
            }
          }
        ' 2>/dev/null || echo "")
      fi

      # Install dependencies for each Composer-installed plugin (with skip check)
      for plugin_dir in ${WP_PLUGINS_DIR}/*/; do
        if [ -f "${plugin_dir}composer.json" ]; then
          PLUGIN_NAME=$(basename "$plugin_dir")

          if echo "$COMPOSER_PLUGIN_SLUGS" | grep -q "^${PLUGIN_NAME}$"; then
            # Skip if vendor/ exists and is not empty
            if [ -d "${plugin_dir}vendor" ] && [ -n "$(ls -A "${plugin_dir}vendor" 2>/dev/null)" ]; then
              [ "${DEBUG}" = "true" ] && echo "DEBUG: Skipping composer install for $PLUGIN_NAME (vendor/ exists)" >&2
              continue
            fi

            echo "Running composer install in plugin: $PLUGIN_NAME"
            cd "$plugin_dir" || continue

            echo "Installing Composer dependencies (this may take a while for plugins with many dependencies)..."

            # Show composer output but filter noise
            # --no-progress shows package operations instead of progress bar (better for logs)
            if composer install --no-dev --no-interaction --ignore-platform-reqs --no-security-blocking --no-progress 2>&1 | \
               grep -v "^$" | \
               while IFS= read -r line; do
                 # Show important lines: operations, generating autoload, warnings, errors
                 if echo "$line" | grep -qE "(^Lock file operations:|^Package operations:|installs|updates|removals|Generating autoload|^  - |Warning|Error|Failed)"; then
                   echo "  $line"
                 fi
               done; then
              echo "Successfully installed dependencies for plugin: $PLUGIN_NAME"
            else
              composer_exit=$?
              echo "Warning: Could not install dependencies for plugin: $PLUGIN_NAME (Exit code: $composer_exit)"
              # Don't fail the whole init script, just warn
            fi

            cd /var/www/html || handle_error "Cannot return to WordPress root directory"
          fi
        fi
      done

      # Create MU-Plugin for Composer autoloader support early
      echo "Creating MU-Plugin for Composer autoloader support..."
      mkdir -p "${WP_MU_PLUGINS_DIR}"
      cat > "${WP_MU_PLUGINS_DIR}/composer-autoloader.php" << 'MUEOF'
    <?php
    /**
     * Plugin Name: Composer Autoloader
     * Description: Automatically loads Composer autoloaders from plugins and themes
     * Author: Helm Chart
     * Version: 1.0.0
     */

    // Load Composer autoloaders from all plugins
    foreach ( glob( WP_CONTENT_DIR . '/plugins/*/vendor/autoload.php' ) as $autoloader ) {
    	require_once $autoloader;
    }

    // Load Composer autoloaders from all themes
    foreach ( glob( WP_CONTENT_DIR . '/themes/*/vendor/autoload.php' ) as $autoloader ) {
    	require_once $autoloader;
    }
    MUEOF
      echo "Composer autoloader MU-Plugin created!"
      echo "Plugin dependencies checked!"

    # Batch activate plugins
    if [ ${#PLUGINS_TO_ACTIVATE[@]} -gt 0 ]; then
      PLUGINS_NEED_ACTIVATION=()
      for plugin in "${PLUGINS_TO_ACTIVATE[@]}"; do
        if ! echo "$ACTIVE_PLUGINS" | grep -q "^${plugin}$"; then
          PLUGINS_NEED_ACTIVATION+=("$plugin")
        fi
      done


      if [ ${#PLUGINS_NEED_ACTIVATION[@]} -gt 0 ]; then
        echo "Activating ${#PLUGINS_NEED_ACTIVATION[@]} plugin(s)..."
        wp plugin activate "${PLUGINS_NEED_ACTIVATION[@]}" 2>/dev/null || echo "Warning: Some plugins could not be activated"
        PLUGINS_MODIFIED=true
      fi
    fi

    # Activate Composer plugins
    # NOTE: This may fail if composer install hasn't run yet - will be retried after composer install
    if [ ${#COMPOSER_PLUGINS_TO_ACTIVATE[@]} -gt 0 ]; then
      COMPOSER_PLUGINS_NEED_ACTIVATION=()
      for plugin in "${COMPOSER_PLUGINS_TO_ACTIVATE[@]}"; do
        if ! echo "$ACTIVE_PLUGINS" | grep -q "^${plugin}$"; then
          COMPOSER_PLUGINS_NEED_ACTIVATION+=("$plugin")
        fi
      done

      if [ ${#COMPOSER_PLUGINS_NEED_ACTIVATION[@]} -gt 0 ]; then
        echo "Activating ${#COMPOSER_PLUGINS_NEED_ACTIVATION[@]} Composer plugin(s)..."
        # Don't fail here - plugins may not exist yet if composer install hasn't run
        # They will be activated after composer install runs
        if ! run wp plugin activate "${COMPOSER_PLUGINS_NEED_ACTIVATION[@]}"; then
          echo "Note: Some Composer plugins couldn't be activated yet - will retry after composer install"
          COMPOSER_PLUGINS_PENDING_ACTIVATION=("${COMPOSER_PLUGINS_NEED_ACTIVATION[@]}")
        else
          ACTIVE_PLUGINS=$(wp_plugin_list --status=active --field=name 2>/dev/null || echo "")
        fi
      fi
    fi

    # Batch enable auto-updates (direct DB update - faster than wp-cli)
    if [ ${#PLUGINS_TO_AUTOUPDATE[@]} -gt 0 ]; then
      PLUGINS_NEED_AUTOUPDATE=()
      for plugin in "${PLUGINS_TO_AUTOUPDATE[@]}"; do
        if ! echo "$AUTOUPDATE_ENABLED" | grep -q "^${plugin}$"; then
          PLUGINS_NEED_AUTOUPDATE+=("$plugin")
        fi
      done


      if [ ${#PLUGINS_NEED_AUTOUPDATE[@]} -gt 0 ]; then
        echo "Enabling auto-updates for ${#PLUGINS_NEED_AUTOUPDATE[@]} plugin(s)..."

        # Get current auto-update plugins from DB
        CURRENT_AUTOUPDATE=$(wp db query "SELECT option_value FROM ${TABLE_PREFIX}options WHERE option_name='auto_update_plugins';" --skip-column-names 2>/dev/null || echo "")

        # Pass plugins as newline-separated string to PHP
        PLUGINS_TO_ADD=$(printf '%s\n' "${PLUGINS_NEED_AUTOUPDATE[@]}")
        export PLUGINS_TO_ADD

        # Use PHP to merge arrays and serialize
        NEW_AUTOUPDATE=$(echo "$CURRENT_AUTOUPDATE" | php -r '
          $current = @unserialize(file_get_contents("php://stdin"));
          if (!is_array($current)) { $current = []; }
          $toAddStr = trim(getenv("PLUGINS_TO_ADD"));
          $toAdd = !empty($toAddStr) ? explode("\n", $toAddStr) : [];

          // Find plugin main file for each slug
          $merged = $current;
          foreach ($toAdd as $slug) {
            // Search for plugin main file (slug/slug.php or any .php in slug/)
            $pluginDir = "/var/www/html/wp-content/plugins/" . $slug;
            if (is_dir($pluginDir)) {
              // Try slug/slug.php first (most common)
              $mainFile = $slug . "/" . $slug . ".php";
              if (!file_exists("/var/www/html/wp-content/plugins/" . $mainFile)) {
                // Find any .php file in the directory
                $files = glob($pluginDir . "/*.php");
                if (!empty($files)) {
                  $mainFile = $slug . "/" . basename($files[0]);
                }
              }
              if (!in_array($mainFile, $merged)) {
                $merged[] = $mainFile;
              }
            }
          }
          echo serialize($merged);
        ' 2>/dev/null)

        # Update database
        if [ -n "$NEW_AUTOUPDATE" ]; then
          # Escape for SQL
          ESCAPED_VALUE=$(echo "$NEW_AUTOUPDATE" | sed "s/'/\\\\'/g")
          wp db query "INSERT INTO ${TABLE_PREFIX}options (option_name, option_value, autoload) VALUES ('auto_update_plugins', '$ESCAPED_VALUE', 'no') ON DUPLICATE KEY UPDATE option_value='$ESCAPED_VALUE';" >/dev/null 2>&1
          echo "Plugin auto-updates enabled!"
        fi
      fi
    fi
    {{- end }}

    {{- if .Values.wordpress.pluginsPrune }}
    # ============================================================================
    # Plugin Pruning - Remove plugins not in the defined list
    # ============================================================================

    # Build comma-separated list of plugins to exclude from deletion
    # Includes both regular plugins and slugs extracted from Composer packages
    EXCLUDE_PLUGINS=""
    COMPOSER_PACKAGES_TO_KEEP=()
    COMPOSER_THEME_PACKAGES_TO_KEEP=()
    {{- $excludeList := list }}
    {{- if .Values.wordpress.plugins }}
    {{- range $plugin := .Values.wordpress.plugins }}
    {{- $name := $plugin.name | lower }}
    {{- if and (contains "/" $name) (not (hasPrefix "http://" $name)) (not (hasPrefix "https://" $name)) }}
    # Composer package: {{ $name }} -> slug: {{ $name | splitList "/" | last }}
    COMPOSER_PACKAGES_TO_KEEP+=("{{ $name }}")
    {{- $excludeList = append $excludeList ($name | splitList "/" | last) }}
    {{- else }}
    # Regular plugin: {{ $name }}
    {{- $excludeList = append $excludeList $name }}
    {{- end }}
    {{- end }}
    {{- end }}
    {{- if $excludeList }}
    EXCLUDE_PLUGINS="{{ $excludeList | join "," }}"
    {{- end }}
    {{- if .Values.wordpress.themes }}
    {{- range .Values.wordpress.themes }}
    {{- $name := .name | lower }}
    {{- if and (contains "/" $name) (not (hasPrefix "http://" $name)) (not (hasPrefix "https://" $name)) }}
    # Composer theme package: {{ $name }}
    COMPOSER_THEME_PACKAGES_TO_KEEP+=("{{ $name }}")
    {{- end }}
    {{- end }}
    {{- end }}
    {{- if .Values.metrics.wordpress.enabled }}
    {{- if .Values.metrics.wordpress.installPlugin }}
    {{- if .Values.metrics.wordpress.pluginNameOverride }}
    [ -n "$EXCLUDE_PLUGINS" ] && EXCLUDE_PLUGINS="${EXCLUDE_PLUGINS},{{ .Values.metrics.wordpress.pluginNameOverride }}" || EXCLUDE_PLUGINS="{{ .Values.metrics.wordpress.pluginNameOverride }}"
    {{- else }}
    [ -n "$EXCLUDE_PLUGINS" ] && EXCLUDE_PLUGINS="${EXCLUDE_PLUGINS},slymetrics" || EXCLUDE_PLUGINS="slymetrics"
    {{- end }}
    {{- end }}
    {{- end }}

    # Delete all plugins except those in the exclude list
    # Only show output if plugins are actually deleted
    if [ -n "$EXCLUDE_PLUGINS" ]; then
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Keeping plugins: $EXCLUDE_PLUGINS"
      PLUGINS_BEFORE=$(wp_plugin_list --field=name 2>/dev/null | wc -l || echo "0")
      wp plugin delete --all --exclude="$EXCLUDE_PLUGINS" >/dev/null 2>&1 || true
      PLUGINS_AFTER=$(wp_plugin_list --field=name 2>/dev/null | wc -l || echo "0")
      PRUNED_COUNT=$((PLUGINS_BEFORE - PLUGINS_AFTER))
      if [ "$PRUNED_COUNT" -gt 0 ]; then
        echo "Pruned $PRUNED_COUNT plugin(s)"
      fi
    else
      PLUGINS_COUNT=$(wp_plugin_list --field=name 2>/dev/null | wc -l || echo "0")
      if [ "$PLUGINS_COUNT" -gt 0 ]; then
        echo "Pruning all $PLUGINS_COUNT plugin(s)..."
        wp plugin delete --all >/dev/null 2>&1 || true
      fi
    fi
    {{- end }}

    # ============================================================================
    # Final Plugin State Refresh
    # ============================================================================
    # Only refresh if we made modifications (performance optimization)
    if [ "$PLUGINS_MODIFIED" = "true" ] || [ "$COMPOSER_PACKAGES_MODIFIED" = "true" ]; then
      echo "Refreshing plugin state after modifications..."
      INSTALLED_PLUGINS=$(wp_plugin_list --field=name 2>/dev/null || echo "")
      ACTIVE_PLUGINS=$(wp_plugin_list --status=active --field=name 2>/dev/null || echo "")
    fi

    # ============================================================================
    # Theme Management
    # ============================================================================
    #
    # Process Overview:
    #   1. Detect package type (Composer vs WP repository vs URL)
    #   2. Validate package names for security
    #   3. Batch operations for performance
    #   4. Install with retry logic for network resilience
    #   5. Activate theme and configure auto-updates
    #
    # Performance Optimizations:
    #   - Batch installation (wp theme install theme1 theme2 theme3)
    #   - Cached theme lists (avoid repeated wp-cli calls)
    #   - Skip already installed packages
    #
    # Error Handling:
    #   - Validation errors: Skip package with warning
    #   - Network errors: Retry with exponential backoff
    #   - Composer errors: Exit with detailed message
    #
    echo "========================================="
    echo "Processing themes..."
    echo "========================================="

    # Cache all theme data upfront (using fast DB queries)
    INSTALLED_THEMES=$(wp_theme_list --field=name 2>/dev/null || echo "")
    ACTIVE_THEME=$(wp_theme_list --status=active --field=name 2>/dev/null || echo "")
    AUTOUPDATE_ENABLED_THEMES=$(wp_theme_list --fields=name,auto_update --format=csv 2>/dev/null | grep ",on$" | cut -d',' -f1 || echo "")

    # Extract theme slug from theme name or URL
    # Handles both direct theme names and .zip URLs
    #
    # Args:
    #   $1 - Theme name or URL (e.g., "astra" or "https://example.com/theme.zip")
    #
    # Returns:
    #   Theme slug (filename without .zip extension for URLs)
    #
    # Examples:
    #   get_theme_slug "astra" -> "astra"
    #   get_theme_slug "https://example.com/mytheme.zip" -> "mytheme"
    get_theme_slug() {
      local theme_name="$1"
      if [[ "$theme_name" == *".zip" ]]; then
        basename "$theme_name" .zip
      else
        echo "$theme_name"
      fi
    }


    THEMES_TO_INSTALL=()
    THEME_TO_ACTIVATE=""
    THEMES_TO_AUTOUPDATE=()

    COMPOSER_THEMES_TO_INSTALL=()
    COMPOSER_THEME_TO_ACTIVATE=""
    COMPOSER_THEMES_TO_UPDATE=()

    {{- range .Values.wordpress.themes }}
    THEME_NAME="{{ .name | lower }}"

    # Validate package name before processing
    if ! validate_package_name "$THEME_NAME"; then
      echo "Skipping invalid theme name: $THEME_NAME"
      continue
    fi

    # Check if it's a Composer package
    if is_composer_package "$THEME_NAME"; then
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Detected Composer theme package: $THEME_NAME"
      COMPOSER_THEME_SLUG=$(get_composer_slug "$THEME_NAME")

      # Check if already installed via composer.json AND theme directory exists
      # Theme might be in composer.json but files deleted (e.g., after pruning)
      if [ -f /var/www/html/composer.json ] && grep -q "\"$THEME_NAME\"" /var/www/html/composer.json 2>/dev/null; then
        if [ -d "/var/www/html/${WP_THEMES_DIR}/${COMPOSER_THEME_SLUG}" ]; then
          [ "${DEBUG}" = "true" ] && echo "DEBUG: Composer theme package $THEME_NAME already installed"

          {{- if .autoupdate }}
          {{- if not .version }}
          # Auto-update only works for packages without fixed version AND already installed
          COMPOSER_THEMES_TO_UPDATE+=("$THEME_NAME")
          {{- else }}
          echo "Note: Auto-update skipped for theme $THEME_NAME (fixed version specified)"
          {{- end }}
          {{- end }}
        else
          # Package in composer.json but files missing - need to run composer install
          echo "Composer theme package $THEME_NAME in composer.json but theme directory missing - will reinstall"
          COMPOSER_PACKAGES_MODIFIED=true
        fi
      else
        {{- if .version }}
        COMPOSER_THEMES_TO_INSTALL+=("{{ .name | lower }}:{{ .version }}")
        {{- else }}
        COMPOSER_THEMES_TO_INSTALL+=("$THEME_NAME")
        {{- end }}
      fi

      {{- if .activate }}
      COMPOSER_THEME_TO_ACTIVATE="$COMPOSER_THEME_SLUG"
      {{- end }}
    else
      THEME_SLUG=$(get_theme_slug "{{ .name | lower }}")

      if ! echo "$INSTALLED_THEMES" | grep -q "^${THEME_SLUG}$"; then
        {{- if .version }}
        THEMES_TO_INSTALL+=("{{ .name | lower }}:{{ .version }}")
        {{- else }}
        THEMES_TO_INSTALL+=("{{ .name | lower }}")
        {{- end }}
      fi
      {{- if .activate }}
      THEME_TO_ACTIVATE="${THEME_SLUG}"
      {{- end }}
      {{- if .autoupdate }}
      THEMES_TO_AUTOUPDATE+=("${THEME_SLUG}")
      {{- end }}
    fi
    {{- end }}

    # Batch install themes
    if [ ${#THEMES_TO_INSTALL[@]} -gt 0 ]; then
      echo "Installing ${#THEMES_TO_INSTALL[@]} theme(s)..."


      THEMES_SIMPLE=()
      THEMES_URLS=()
      THEMES_WITH_VERSION=()


      for theme_spec in "${THEMES_TO_INSTALL[@]}"; do
        if [[ "$theme_spec" == http://* ]] || [[ "$theme_spec" == https://* ]]; then
          THEMES_URLS+=("$theme_spec")
        elif [[ "$theme_spec" == *":"* ]]; then
          THEMES_WITH_VERSION+=("$theme_spec")
        else
          THEMES_SIMPLE+=("$theme_spec")
        fi
      done


      if [ ${#THEMES_SIMPLE[@]} -gt 0 ]; then
        retry_command wp theme install "${THEMES_SIMPLE[@]}" --force || echo "Warning: Some themes failed to install"
      fi


      for theme_url in "${THEMES_URLS[@]}"; do
        echo "Installing theme from URL: $theme_url"
        retry_command wp theme install "$theme_url" --force || echo "Warning: Failed to install theme from URL: $theme_url"
      done


      for theme_spec in "${THEMES_WITH_VERSION[@]}"; do
        THEME_NAME="${theme_spec%%:*}"
        THEME_VERSION="${theme_spec##*:}"
        echo "Installing theme ${THEME_NAME} version ${THEME_VERSION}..."
        retry_command wp theme install "${THEME_NAME}" --version="${THEME_VERSION}" --force || echo "Warning: Failed to install theme: ${THEME_NAME}"
      done


      INSTALLED_THEMES=$(wp_theme_list --field=name 2>/dev/null || echo "")
      ACTIVE_THEME=$(wp_theme_list --status=active --field=name 2>/dev/null || echo "")
    fi

    # Install Composer themes
    if [ ${#COMPOSER_THEMES_TO_INSTALL[@]} -gt 0 ]; then
      echo "Installing ${#COMPOSER_THEMES_TO_INSTALL[@]} Composer theme(s)..."
      cd /var/www/html || handle_error "Failed to change to /var/www/html directory"

      for package_spec in "${COMPOSER_THEMES_TO_INSTALL[@]}"; do
        echo "Installing Composer theme package: $package_spec"
        # Capture output and only show on error, with retry logic
        if ! COMPOSER_OUTPUT=$(retry_command composer require "$package_spec" --no-interaction 2>&1); then
          echo "$COMPOSER_OUTPUT"
          handle_error "Error installing Composer theme package: $package_spec (failed after retries)"
        fi
      done

      echo "Composer themes installed!"
      COMPOSER_PACKAGES_MODIFIED=true
      INSTALLED_THEMES=$(wp_theme_list --field=name 2>/dev/null || echo "")
      ACTIVE_THEME=$(wp_theme_list --status=active --field=name 2>/dev/null || echo "")
    fi

    # Update Composer themes (auto-update for packages without fixed version)
    if [ ${#COMPOSER_THEMES_TO_UPDATE[@]} -gt 0 ]; then
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Checking for Composer theme updates..."
      cd /var/www/html || handle_error "Failed to change to /var/www/html directory"

      # Get list of outdated packages once (performance optimization)
      # Re-use existing OUTDATED_PACKAGES if already fetched, otherwise fetch now
      if [ -z "$OUTDATED_PACKAGES" ]; then
        OUTDATED_PACKAGES=$(composer outdated --direct --format=json 2>/dev/null | php -r '
          $json = json_decode(file_get_contents("php://stdin"), true);
          if (isset($json["installed"])) {
            foreach ($json["installed"] as $pkg) {
              echo $pkg["name"] . "\n";
            }
          }
        ' 2>/dev/null || echo "")
      fi

      THEMES_UPDATED=0
      for package in "${COMPOSER_THEMES_TO_UPDATE[@]}"; do
        # Check if package has an available update
        if echo "$OUTDATED_PACKAGES" | grep -q "^${package}$"; then
          echo "Updating Composer theme package: $package"
          # Capture output and only show on error, with retry logic
          if ! COMPOSER_OUTPUT=$(retry_command composer update "$package" --no-interaction 2>&1); then
            echo "$COMPOSER_OUTPUT"
            handle_error "Error updating Composer theme package: $package (failed after retries)"
          fi
          THEMES_UPDATED=$((THEMES_UPDATED + 1))
        else
          [ "${DEBUG}" = "true" ] && echo "DEBUG: Theme package $package is already up to date" >&2
        fi
      done

      if [ $THEMES_UPDATED -gt 0 ]; then
        echo "$THEMES_UPDATED Composer theme(s) updated!"
        COMPOSER_PACKAGES_MODIFIED=true
      fi
    fi

    # Activate theme
    if [ -n "$THEME_TO_ACTIVATE" ] && [ "$ACTIVE_THEME" != "$THEME_TO_ACTIVATE" ]; then
      echo "Activating theme: $THEME_TO_ACTIVATE"
      run wp theme activate "$THEME_TO_ACTIVATE"
    fi

    # Activate Composer theme
    if [ -n "$COMPOSER_THEME_TO_ACTIVATE" ] && [ "$ACTIVE_THEME" != "$COMPOSER_THEME_TO_ACTIVATE" ]; then
      echo "Activating Composer theme: $COMPOSER_THEME_TO_ACTIVATE"
      run wp theme activate "$COMPOSER_THEME_TO_ACTIVATE"
    fi

    # Batch enable auto-updates (direct DB update - faster than wp-cli)
    if [ ${#THEMES_TO_AUTOUPDATE[@]} -gt 0 ]; then
      THEMES_NEED_AUTOUPDATE=()
      for theme in "${THEMES_TO_AUTOUPDATE[@]}"; do
        if ! echo "$AUTOUPDATE_ENABLED_THEMES" | grep -q "^${theme}$"; then
          THEMES_NEED_AUTOUPDATE+=("$theme")
        fi
      done


      if [ ${#THEMES_NEED_AUTOUPDATE[@]} -gt 0 ]; then
        echo "Enabling auto-updates for ${#THEMES_NEED_AUTOUPDATE[@]} theme(s)..."

        # Get current auto-update themes from DB
        CURRENT_AUTOUPDATE_THEMES=$(wp db query "SELECT option_value FROM ${TABLE_PREFIX}options WHERE option_name='auto_update_themes';" --skip-column-names 2>/dev/null || echo "")

        # Pass themes as newline-separated string to PHP
        THEMES_TO_ADD=$(printf '%s\n' "${THEMES_NEED_AUTOUPDATE[@]}")
        export THEMES_TO_ADD

        # Use PHP to merge arrays and serialize
        NEW_AUTOUPDATE_THEMES=$(echo "$CURRENT_AUTOUPDATE_THEMES" | php -r '
          $current = @unserialize(file_get_contents("php://stdin"));
          if (!is_array($current)) { $current = []; }
          $toAddStr = trim(getenv("THEMES_TO_ADD"));
          $toAdd = !empty($toAddStr) ? explode("\n", $toAddStr) : [];

          // Merge theme slugs
          $merged = array_unique(array_merge($current, $toAdd));
          echo serialize($merged);
        ' 2>/dev/null)

        # Update database
        if [ -n "$NEW_AUTOUPDATE_THEMES" ]; then
          # Escape for SQL
          ESCAPED_VALUE=$(echo "$NEW_AUTOUPDATE_THEMES" | sed "s/'/\\\\'/g")
          wp db query "INSERT INTO ${TABLE_PREFIX}options (option_name, option_value, autoload) VALUES ('auto_update_themes', '$ESCAPED_VALUE', 'no') ON DUPLICATE KEY UPDATE option_value='$ESCAPED_VALUE';" >/dev/null 2>&1
          echo "Theme auto-updates enabled!"
        fi
      fi
    fi

    {{- if .Values.wordpress.themesPrune }}
    # ============================================================================
    # Theme Pruning - Remove themes not in the defined list
    # ============================================================================

    # Build list of theme slugs to keep
    THEMES_TO_KEEP=()
    {{- if .Values.wordpress.themes }}
    {{- range .Values.wordpress.themes }}
    {{- $name := .name | lower }}
    {{- if and (contains "/" $name) (not (hasPrefix "http://" $name)) (not (hasPrefix "https://" $name)) }}
    # Composer theme package: {{ $name }}
    # Extract theme slug from Composer package name (e.g., wpackagist-theme/astra -> astra)
    THEME_SLUG=$(echo "{{ $name }}" | sed 's/.*\///')
    THEMES_TO_KEEP+=("$THEME_SLUG")
    {{- else }}
    # Regular theme: {{ $name }}
    THEME_SLUG=$(get_theme_slug "{{ $name }}")
    THEMES_TO_KEEP+=("$THEME_SLUG")
    {{- end }}
    {{- end }}
    {{- end }}

    # Get all installed themes and active theme
    INSTALLED_THEMES=$(wp_theme_list --field=name 2>/dev/null || echo "")
    ACTIVE_THEME=$(wp_theme_list --status=active --field=name 2>/dev/null || echo "")

    # Check if active theme should be pruned (will be handled before deletion)
    ACTIVE_THEME_SHOULD_BE_PRUNED=false
    if [ -n "$ACTIVE_THEME" ]; then
      ACTIVE_IN_KEEP_LIST=false
      for keep_theme in "${THEMES_TO_KEEP[@]}"; do
        if [ "$ACTIVE_THEME" = "$keep_theme" ]; then
          ACTIVE_IN_KEEP_LIST=true
          break
        fi
      done

      if [ "$ACTIVE_IN_KEEP_LIST" = false ]; then
        ACTIVE_THEME_SHOULD_BE_PRUNED=true

        # Try to activate a theme from the keep list
        FALLBACK_THEME=""
        for keep_theme in "${THEMES_TO_KEEP[@]}"; do
          if echo "$INSTALLED_THEMES" | grep -q "^${keep_theme}$"; then
            FALLBACK_THEME="$keep_theme"
            break
          fi
        done

        if [ -n "$FALLBACK_THEME" ]; then
          echo "Activating fallback theme: $FALLBACK_THEME (current active theme '$ACTIVE_THEME' is not in keep list)"
          if wp theme activate "$FALLBACK_THEME" 2>/dev/null; then
            echo "Successfully activated fallback theme: $FALLBACK_THEME"
            ACTIVE_THEME="$FALLBACK_THEME"
          else
            echo "ERROR: Failed to activate fallback theme. Active theme '$ACTIVE_THEME' will be kept to prevent site breakage." >&2
            ACTIVE_THEME_SHOULD_BE_PRUNED=false
          fi
        else
          echo "ERROR: Active theme '$ACTIVE_THEME' is not in keep list but no alternative theme available. Keeping it to prevent site breakage." >&2
          ACTIVE_THEME_SHOULD_BE_PRUNED=false
        fi
      fi
    fi

    # Build list of themes to delete (installed themes minus keep list minus active theme)
    THEMES_TO_DELETE=()
    for theme in $INSTALLED_THEMES; do
      # Safety: Never delete the active theme (even if it should be pruned but couldn't be switched)
      if [ "$theme" = "$ACTIVE_THEME" ]; then
        continue
      fi

      # Check if theme is in the keep list
      KEEP=false
      for keep_theme in "${THEMES_TO_KEEP[@]}"; do
        if [ "$theme" = "$keep_theme" ]; then
          KEEP=true
          break
        fi
      done

      if [ "$KEEP" = false ]; then
        THEMES_TO_DELETE+=("$theme")
      fi
    done

    # Delete all themes in one command for better performance
    if [ ${#THEMES_TO_DELETE[@]} -gt 0 ]; then
      echo "Pruning ${#THEMES_TO_DELETE[@]} theme(s): ${THEMES_TO_DELETE[*]}"
      wp theme delete "${THEMES_TO_DELETE[@]}" 2>/dev/null || true
    fi

    # Remove Composer packages (plugins & themes) not in the keep lists
    if [ -f /var/www/html/composer.json ]; then
      cd /var/www/html || handle_error "Failed to change to /var/www/html directory"

      # Ensure Composer is available for pruning operations
      ensure_composer

      # Get all currently required packages from composer.json (excluding composer/installers)
      # Use PHP for reliable JSON parsing (performance: single process vs multiple sed/grep calls)
      if [ -f composer.json ]; then
        CURRENT_PACKAGES=$(php -r '
          $json = json_decode(file_get_contents("composer.json"), true);
          if (isset($json["require"])) {
            foreach ($json["require"] as $package => $version) {
              if ($package !== "composer/installers") {
                echo $package . "\n";
              }
            }
          }
        ' 2>/dev/null || echo "")
      else
        CURRENT_PACKAGES=""
      fi

      # Debug: Show what we're keeping
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Composer packages to keep: ${COMPOSER_PACKAGES_TO_KEEP[*]}" >&2
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Composer theme packages to keep: ${COMPOSER_THEME_PACKAGES_TO_KEEP[*]}" >&2
      [ "${DEBUG}" = "true" ] && echo "DEBUG: Current packages in composer.json: $CURRENT_PACKAGES" >&2

      # Get active theme (might be a Composer theme)
      ACTIVE_THEME=$(wp_theme_list --status=active --field=name 2>/dev/null || echo "")

      # Track packages that should be removed
      PACKAGES_TO_REMOVE=()
      ACTIVE_THEME_PACKAGE=""

      for package in $CURRENT_PACKAGES; do
        KEEP=false

        # Check if it's in the plugin keep list
        for keep_package in "${COMPOSER_PACKAGES_TO_KEEP[@]}"; do
          if [ "$package" = "$keep_package" ]; then
            KEEP=true
            break
          fi
        done

        # If not found in plugins, check theme keep list
        if [ "$KEEP" = false ]; then
          for keep_package in "${COMPOSER_THEME_PACKAGES_TO_KEEP[@]}"; do
            if [ "$package" = "$keep_package" ]; then
              KEEP=true
              break
            fi
          done
        fi

        # Check if this package is the active theme
        if [[ "$package" == wpackagist-theme/* ]]; then
          PACKAGE_SLUG="${package#wpackagist-theme/}"
          if [ "$PACKAGE_SLUG" = "$ACTIVE_THEME" ]; then
            ACTIVE_THEME_PACKAGE="$package"
            if [ "$KEEP" = false ]; then
              echo "WARNING: Active theme '$ACTIVE_THEME' is a Composer package ($package) not in the keep list"
            else
              # Active theme is in keep list, safe to continue
              continue
            fi
          fi
        fi

        if [ "$KEEP" = false ]; then
          PACKAGES_TO_REMOVE+=("$package")
        fi
      done

      # If active theme should be removed, try to activate fallback first
      # Note: This handles Composer theme packages that were already checked during WordPress theme pruning
      if [ -n "$ACTIVE_THEME_PACKAGE" ]; then
        # Only show message if we haven't already handled this theme above
        if [ "$ACTIVE_THEME_SHOULD_BE_PRUNED" = "false" ]; then
          # Theme was already processed above, just skip removal silently
          TEMP_PACKAGES=()
          for pkg in "${PACKAGES_TO_REMOVE[@]}"; do
            if [ "$pkg" != "$ACTIVE_THEME_PACKAGE" ]; then
              TEMP_PACKAGES+=("$pkg")
            fi
          done
          PACKAGES_TO_REMOVE=("${TEMP_PACKAGES[@]}")
        fi
        # If ACTIVE_THEME_SHOULD_BE_PRUNED=true, the theme was already switched above, so we can safely remove it
      fi

      # Remove all packages in one go
      if [ ${#PACKAGES_TO_REMOVE[@]} -gt 0 ]; then
        echo "========================================="
        echo "Pruning Composer packages..."
        echo "========================================="
        echo "Removing ${#PACKAGES_TO_REMOVE[@]} Composer package(s): ${PACKAGES_TO_REMOVE[*]}"
        for package in "${PACKAGES_TO_REMOVE[@]}"; do
          echo "Removing: $package"
          if ! COMPOSER_OUTPUT=$(composer remove "$package" --no-interaction --quiet 2>&1); then
            echo "$COMPOSER_OUTPUT"
            echo "Error removing Composer package: $package"
          fi
        done
        echo "Composer packages pruned successfully!"
      fi
    fi
    {{- end }}

    # Install Composer theme dependencies after theme installation
    # Plugin dependencies were already installed before theme processing
    #
    # This section handles:
    #   - Running composer install for themes with their own composer.json
    #   - Activating Composer plugins that couldn't be activated before
    #
    # Note: Main composer install and plugin dependencies were already done
    # before theme installation to prevent loading errors (e.g., s3-uploads AWS SDK)
    if [ "$COMPOSER_PACKAGES_MODIFIED" = "true" ] || [ ! -d /var/www/html/vendor ]; then
      cd /var/www/html || handle_error "Failed to change to /var/www/html directory"

      # Ensure vendor directory exists (may have been created during plugin dependency install)
      if [ ! -d /var/www/html/vendor ]; then
        echo "Vendor directory missing, running composer install..."
        if ! COMPOSER_OUTPUT=$(retry_command composer install --no-interaction 2>&1 | grep -v "suggest" | grep -v "funding"); then
          echo "$COMPOSER_OUTPUT"
          handle_error "Error installing Composer dependencies (failed after retries)"
        fi
      fi

      # Build list of Composer-installed theme slugs from the require list
      COMPOSER_THEME_SLUGS=""
      if [ -f composer.json ]; then
        COMPOSER_THEME_SLUGS=$(php -r '
          $json = json_decode(file_get_contents("composer.json"), true);
          if (isset($json["require"])) {
            foreach ($json["require"] as $package => $version) {
              // Only process theme packages
              if (strpos($package, "wpackagist-theme/") === 0 ||
                  (strpos($package, "/") !== false && strpos($package, "theme") !== false)) {
                $slug = substr($package, strrpos($package, "/") + 1);
                echo $slug . "\n";
              }
            }
          }
        ' 2>/dev/null || echo "")
      fi

      # Install theme-specific Composer dependencies
      THEMES_WITH_DEPS=0
      for theme_dir in ${WP_THEMES_DIR}/*/; do
        if [ -f "${theme_dir}composer.json" ]; then
          THEME_NAME=$(basename "$theme_dir")

          # Only run composer install if this theme was installed via Composer
          if echo "$COMPOSER_THEME_SLUGS" | grep -q "^${THEME_NAME}$"; then
            [ $THEMES_WITH_DEPS -eq 0 ] && echo "Installing theme-specific Composer dependencies..."
            echo "Running composer install in theme: $THEME_NAME"
            cd "$theme_dir" || continue
            if composer install --no-dev --no-interaction --ignore-platform-reqs --quiet 2>&1 | grep -E "Error|Warning|Failed" > /tmp/composer-error.txt; then
              cat /tmp/composer-error.txt
              echo "Warning: Could not install dependencies for theme: $THEME_NAME"
            else
              echo "Successfully installed dependencies for theme: $THEME_NAME"
            fi
            cd /var/www/html || handle_error "Cannot return to WordPress root directory"
            THEMES_WITH_DEPS=$((THEMES_WITH_DEPS + 1))
          else
            [ "${DEBUG}" = "true" ] && echo "DEBUG: Skipping $THEME_NAME - not a Composer-installed theme" >&2
          fi
        fi
      done

      # Activate Composer plugins that couldn't be activated before (dependencies were missing)
      if [ ${#COMPOSER_PLUGINS_PENDING_ACTIVATION[@]} -gt 0 ]; then
        echo "Activating Composer plugins after dependency installation..."
        ACTIVE_PLUGINS=$(wp_plugin_list --status=active --field=name 2>/dev/null || echo "")
        PLUGINS_STILL_NEED_ACTIVATION=()
        for plugin in "${COMPOSER_PLUGINS_PENDING_ACTIVATION[@]}"; do
          if ! echo "$ACTIVE_PLUGINS" | grep -q "^${plugin}$"; then
            PLUGINS_STILL_NEED_ACTIVATION+=("$plugin")
          fi
        done
        if [ ${#PLUGINS_STILL_NEED_ACTIVATION[@]} -gt 0 ]; then
          echo "Activating ${#PLUGINS_STILL_NEED_ACTIVATION[@]} Composer plugin(s)..."
          run wp plugin activate "${PLUGINS_STILL_NEED_ACTIVATION[@]}" || echo "Warning: Some plugins could not be activated"
        fi
      fi
    fi

    # ============================================================================
    # Custom Init Commands
    # ============================================================================
    {{- if .Values.wordpress.init.customInitConfigMap.name }}


    echo "Running custom init commands from ConfigMap..."
    if [ -f /tmp/custom-init-commands/{{ .Values.wordpress.init.customInitConfigMap.key | default "commands.sh" }} ]; then
      # Execute the custom commands script (already executable via defaultMode: 0755)
      /tmp/custom-init-commands/{{ .Values.wordpress.init.customInitConfigMap.key | default "commands.sh" }}
      echo "Custom init commands completed!"
    else
      echo "Warning: Custom commands file not found in ConfigMap"
    fi
    {{- end }}


    # ============================================================================
    # Final Rewrite Flush (single flush at the end)
    # ============================================================================
    if [ "$PLUGINS_MODIFIED" = "true" ] || [ "$COMPOSER_PACKAGES_MODIFIED" = "true" ]; then
      echo "Flushing rewrite rules after all changes..."
      run wp rewrite flush
    fi

    # ============================================================================
    # Release Lock and Complete
    # ============================================================================

    # Print test summary if in TEST_MODE
    test_summary

    # Lock will be released automatically via trap on EXIT
    echo "Database lock released."
    echo "Init script completed successfully!"

    # Explicitly exit with success code
    exit 0